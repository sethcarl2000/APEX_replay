
#include <TROOT.h>
#include "TMath.h"
#include "ApexHRS.h"
#include <fstream>


const double R_abs[4][368] = {{1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31579e-06,1.31569e-06,1.31487e-06,1.31633e-06,1.31532e-06,1.31552e-06,1.31554e-06,1.31546e-06,1.31508e-06,1.31569e-06,1.3152e-06,1.31592e-06,1.31553e-06,1.31586e-06,1.31597e-06,1.31633e-06,1.31584e-06,1.31591e-06,1.31582e-06,1.31748e-06,1.31664e-06,1.31684e-06,1.31656e-06,1.31719e-06,1.31662e-06,1.31747e-06,1.3175e-06,1.31648e-06,1.31635e-06,1.31706e-06,1.31638e-06,1.31637e-06,1.3162e-06,1.3164e-06,1.31547e-06,1.31827e-06,1.31621e-06,1.31794e-06,1.31717e-06,1.31806e-06,1.31779e-06,1.31773e-06,1.31836e-06,1.31814e-06,1.31819e-06,1.31881e-06,1.31846e-06,1.31866e-06,1.31892e-06,1.31877e-06,1.31813e-06,1.3182e-06,1.31648e-06,1.31696e-06,1.31693e-06,1.31735e-06,1.31696e-06,1.31732e-06,1.31754e-06,1.31642e-06,1.31632e-06,1.31669e-06,1.31705e-06,1.31659e-06,1.31645e-06,1.31684e-06,1.31658e-06,1.32143e-06,1.32022e-06,1.32059e-06,1.32061e-06,1.32111e-06,1.32078e-06,1.32132e-06,1.32078e-06,1.32127e-06,1.32101e-06,1.32151e-06,1.32175e-06,1.32161e-06,1.3217e-06,1.32206e-06,1.32178e-06,1.32367e-06,1.32228e-06,1.32354e-06,1.32247e-06,1.32285e-06,1.32245e-06,1.3229e-06,1.32288e-06,1.32201e-06,1.32146e-06,1.32267e-06,1.32199e-06,1.32212e-06,1.32184e-06,1.32213e-06,1.32162e-06,1.32439e-06,1.32282e-06,1.32435e-06,1.32285e-06,1.32398e-06,1.32371e-06,1.32366e-06,1.32387e-06,1.32368e-06,1.32388e-06,1.32414e-06,1.32392e-06,1.32432e-06,1.32399e-06,1.32419e-06,1.32316e-06,1.3242e-06,1.32337e-06,1.32355e-06,1.32347e-06,1.32423e-06,1.32356e-06,1.32489e-06,1.32489e-06,1.32376e-06,1.32381e-06,1.32436e-06,1.32381e-06,1.32397e-06,1.32399e-06,1.324e-06,1.3233e-06,1.3262e-06,1.3244e-06,1.32553e-06,1.32502e-06,1.32549e-06,1.32505e-06,1.32594e-06,1.3251e-06,1.32575e-06,1.3256e-06,1.32602e-06,1.32538e-06,1.32624e-06,1.32574e-06,1.32657e-06,1.32516e-06,1.32897e-06,1.32723e-06,1.32816e-06,1.32782e-06,1.32846e-06,1.32785e-06,1.32898e-06,1.32845e-06,1.32768e-06,1.32711e-06,1.32827e-06,1.32731e-06,1.32758e-06,1.32706e-06,1.32753e-06,1.32729e-06,1.32767e-06,1.32672e-06,1.32777e-06,1.32697e-06,1.32792e-06,1.32727e-06,1.32749e-06,1.32802e-06,1.32781e-06,1.32697e-06,1.32786e-06,1.32687e-06,1.32774e-06,1.32755e-06,1.32784e-06,1.3269e-06,1.32983e-06,1.32871e-06,1.32888e-06,1.3295e-06,1.32916e-06,1.32916e-06,1.32949e-06,1.33002e-06,1.3288e-06,1.3286e-06,1.32933e-06,1.32886e-06,1.32914e-06,1.32876e-06,1.32918e-06,1.32827e-06,1.32989e-06,1.32792e-06,1.32945e-06,1.32839e-06,1.32927e-06,1.3291e-06,1.32885e-06,1.32931e-06,1.32916e-06,1.32921e-06,1.32979e-06,1.32926e-06,1.32949e-06,1.3291e-06,1.32888e-06,1.32863e-06,1.329e-06,1.32765e-06,1.32908e-06,1.32818e-06,1.32859e-06,1.32862e-06,1.32843e-06,1.32915e-06,1.3282e-06,1.32836e-06,1.3288e-06,1.32837e-06,1.32872e-06,1.32857e-06,1.32903e-06,1.32801e-06,1.33359e-06,1.33126e-06,1.33347e-06,1.33211e-06,1.33365e-06,1.33354e-06,1.33319e-06,1.33357e-06,1.33376e-06,1.33383e-06,1.3343e-06,1.33388e-06,1.33424e-06,1.3341e-06,1.33417e-06,1.33326e-06,1.33279e-06,1.33115e-06,1.33259e-06,1.33152e-06,1.33258e-06,1.33164e-06,1.33198e-06,1.33201e-06,1.33117e-06,1.33115e-06,1.33169e-06,1.33133e-06,1.33165e-06,1.3319e-06,1.33176e-06,1.33132e-06,1.33494e-06,1.33409e-06,1.33508e-06,1.33407e-06,1.33476e-06,1.33397e-06,1.33423e-06,1.3344e-06,1.33437e-06,1.33406e-06,1.33486e-06,1.33441e-06,1.33491e-06,1.33485e-06,1.33529e-06,1.33446e-06,1.33707e-06,1.33533e-06,1.33698e-06,1.33647e-06,1.33768e-06,1.33667e-06,1.33692e-06,1.33738e-06,1.33666e-06,1.33681e-06,1.33739e-06,1.33675e-06,1.33699e-06,1.33617e-06,1.33716e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06,1.33631e-06},{1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31809e-06,1.31822e-06,1.31773e-06,1.32001e-06,1.31852e-06,1.31986e-06,1.31887e-06,1.32033e-06,1.31974e-06,1.31941e-06,1.31985e-06,1.3199e-06,1.32e-06,1.32094e-06,1.31765e-06,1.32096e-06,1.32019e-06,1.31986e-06,1.31947e-06,1.32204e-06,1.31956e-06,1.32149e-06,1.32032e-06,1.32141e-06,1.32096e-06,1.32091e-06,1.32092e-06,1.32067e-06,1.3203e-06,1.32034e-06,1.32036e-06,1.32115e-06,1.32061e-06,1.32094e-06,1.31973e-06,1.32221e-06,1.32041e-06,1.32171e-06,1.32092e-06,1.32191e-06,1.32135e-06,1.32167e-06,1.32173e-06,1.3217e-06,1.32179e-06,1.32173e-06,1.32167e-06,1.32212e-06,1.32148e-06,1.32196e-06,1.32082e-06,1.3235e-06,1.32209e-06,1.32328e-06,1.32226e-06,1.32348e-06,1.32308e-06,1.3231e-06,1.32315e-06,1.32261e-06,1.32194e-06,1.3229e-06,1.32193e-06,1.32277e-06,1.32247e-06,1.32236e-06,1.32132e-06,1.32472e-06,1.32368e-06,1.32354e-06,1.32403e-06,1.32436e-06,1.32379e-06,1.32418e-06,1.32459e-06,1.32404e-06,1.32393e-06,1.32389e-06,1.32471e-06,1.32392e-06,1.32417e-06,1.32444e-06,1.32441e-06,1.32547e-06,1.32364e-06,1.32545e-06,1.32406e-06,1.32523e-06,1.32459e-06,1.32414e-06,1.32545e-06,1.32449e-06,1.32396e-06,1.32435e-06,1.32452e-06,1.32474e-06,1.32417e-06,1.32427e-06,1.32357e-06,1.32642e-06,1.32489e-06,1.32575e-06,1.32531e-06,1.32558e-06,1.32553e-06,1.32594e-06,1.32558e-06,1.32574e-06,1.32536e-06,1.32526e-06,1.32646e-06,1.32529e-06,1.32542e-06,1.32572e-06,1.32522e-06,1.32593e-06,1.32548e-06,1.32562e-06,1.32521e-06,1.3259e-06,1.32556e-06,1.32591e-06,1.32606e-06,1.32513e-06,1.32524e-06,1.32506e-06,1.32576e-06,1.32551e-06,1.32516e-06,1.32546e-06,1.32486e-06,1.32784e-06,1.32601e-06,1.32724e-06,1.32674e-06,1.32718e-06,1.32667e-06,1.32763e-06,1.32701e-06,1.32715e-06,1.3269e-06,1.3271e-06,1.32722e-06,1.32703e-06,1.32669e-06,1.32724e-06,1.32664e-06,1.32854e-06,1.32696e-06,1.32828e-06,1.32769e-06,1.32841e-06,1.32738e-06,1.32811e-06,1.32795e-06,1.32717e-06,1.32718e-06,1.32794e-06,1.32699e-06,1.32776e-06,1.32726e-06,1.32784e-06,1.32671e-06,1.33053e-06,1.32913e-06,1.33028e-06,1.32953e-06,1.33005e-06,1.32978e-06,1.32948e-06,1.32972e-06,1.32958e-06,1.3292e-06,1.3298e-06,1.32927e-06,1.32938e-06,1.32928e-06,1.32986e-06,1.32892e-06,1.3303e-06,1.32931e-06,1.33064e-06,1.32953e-06,1.33086e-06,1.32983e-06,1.32973e-06,1.33057e-06,1.32919e-06,1.32904e-06,1.32931e-06,1.32899e-06,1.32948e-06,1.32933e-06,1.3295e-06,1.32884e-06,1.33125e-06,1.33041e-06,1.33098e-06,1.33102e-06,1.33145e-06,1.33144e-06,1.33188e-06,1.33184e-06,1.33159e-06,1.33106e-06,1.33177e-06,1.33146e-06,1.33162e-06,1.33081e-06,1.33236e-06,1.3306e-06,1.33208e-06,1.33132e-06,1.33192e-06,1.33143e-06,1.33137e-06,1.33155e-06,1.33162e-06,1.33097e-06,1.33082e-06,1.3307e-06,1.33037e-06,1.33129e-06,1.33058e-06,1.33067e-06,1.33157e-06,1.33057e-06,1.33308e-06,1.33146e-06,1.3333e-06,1.33218e-06,1.33255e-06,1.33277e-06,1.33305e-06,1.33264e-06,1.33221e-06,1.33248e-06,1.33228e-06,1.33302e-06,1.333e-06,1.33229e-06,1.33359e-06,1.33293e-06,1.33315e-06,1.33275e-06,1.33297e-06,1.33271e-06,1.33252e-06,1.33235e-06,1.33251e-06,1.33237e-06,1.33153e-06,1.33162e-06,1.332e-06,1.33207e-06,1.33207e-06,1.33225e-06,1.3323e-06,1.33194e-06,1.33667e-06,1.33276e-06,1.33505e-06,1.3373e-06,1.33424e-06,1.33698e-06,1.33562e-06,1.33677e-06,1.33663e-06,1.33556e-06,1.3366e-06,1.33722e-06,1.33438e-06,1.33351e-06,1.33852e-06,1.33672e-06,1.33647e-06,1.33737e-06,1.33795e-06,1.33825e-06,1.33732e-06,1.33714e-06,1.3384e-06,1.33826e-06,1.33749e-06,1.33731e-06,1.3373e-06,1.33833e-06,1.33723e-06,1.33729e-06,1.33841e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06,1.33757e-06},{1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31578e-06,1.31698e-06,1.3155e-06,1.31785e-06,1.31687e-06,1.31702e-06,1.3172e-06,1.31786e-06,1.31773e-06,1.3181e-06,1.31831e-06,1.31815e-06,1.31816e-06,1.31868e-06,1.31841e-06,1.31844e-06,1.31841e-06,1.31853e-06,1.31824e-06,1.31755e-06,1.3168e-06,1.31706e-06,1.317e-06,1.31729e-06,1.31692e-06,1.31711e-06,1.31742e-06,1.31659e-06,1.31661e-06,1.31712e-06,1.31736e-06,1.31694e-06,1.31705e-06,1.31731e-06,1.31649e-06,1.31825e-06,1.31663e-06,1.31747e-06,1.3173e-06,1.31788e-06,1.31781e-06,1.31805e-06,1.31804e-06,1.31804e-06,1.31807e-06,1.31796e-06,1.31861e-06,1.31856e-06,1.31827e-06,1.3186e-06,1.31781e-06,1.32062e-06,1.31924e-06,1.31971e-06,1.31963e-06,1.31937e-06,1.31935e-06,1.32006e-06,1.31939e-06,1.31946e-06,1.31845e-06,1.31968e-06,1.31885e-06,1.31968e-06,1.31842e-06,1.31969e-06,1.31822e-06,1.32356e-06,1.3221e-06,1.32316e-06,1.32213e-06,1.32334e-06,1.32296e-06,1.32278e-06,1.32326e-06,1.32343e-06,1.32225e-06,1.32363e-06,1.32306e-06,1.32327e-06,1.3224e-06,1.32333e-06,1.3224e-06,1.32442e-06,1.32241e-06,1.32394e-06,1.32317e-06,1.32418e-06,1.32356e-06,1.32323e-06,1.32414e-06,1.32317e-06,1.32289e-06,1.3234e-06,1.32263e-06,1.32338e-06,1.32243e-06,1.32252e-06,1.32259e-06,1.32317e-06,1.32204e-06,1.32368e-06,1.32244e-06,1.32319e-06,1.32294e-06,1.32255e-06,1.3232e-06,1.32338e-06,1.32276e-06,1.32358e-06,1.32304e-06,1.32395e-06,1.32323e-06,1.32368e-06,1.32296e-06,1.32585e-06,1.32379e-06,1.32507e-06,1.32461e-06,1.32546e-06,1.32485e-06,1.32483e-06,1.32569e-06,1.32432e-06,1.32416e-06,1.32472e-06,1.32408e-06,1.32464e-06,1.32461e-06,1.32473e-06,1.32369e-06,1.32658e-06,1.32562e-06,1.32646e-06,1.32593e-06,1.32613e-06,1.32574e-06,1.32662e-06,1.3258e-06,1.3257e-06,1.32606e-06,1.326e-06,1.32634e-06,1.32554e-06,1.32594e-06,1.32644e-06,1.32589e-06,1.32752e-06,1.32657e-06,1.32759e-06,1.3273e-06,1.32833e-06,1.32733e-06,1.32783e-06,1.3281e-06,1.32683e-06,1.32595e-06,1.3271e-06,1.32601e-06,1.32703e-06,1.32592e-06,1.32705e-06,1.32593e-06,1.32629e-06,1.32549e-06,1.32587e-06,1.32558e-06,1.32563e-06,1.32581e-06,1.32555e-06,1.32605e-06,1.32592e-06,1.32562e-06,1.32577e-06,1.32623e-06,1.32578e-06,1.32596e-06,1.32656e-06,1.3259e-06,1.32833e-06,1.32686e-06,1.32767e-06,1.32715e-06,1.32749e-06,1.32717e-06,1.32786e-06,1.32734e-06,1.3275e-06,1.32698e-06,1.32686e-06,1.32752e-06,1.32733e-06,1.3273e-06,1.3278e-06,1.32711e-06,1.33061e-06,1.32921e-06,1.3301e-06,1.32975e-06,1.33046e-06,1.33006e-06,1.33063e-06,1.33074e-06,1.33068e-06,1.33084e-06,1.33077e-06,1.33141e-06,1.33122e-06,1.33015e-06,1.33173e-06,1.33053e-06,1.32959e-06,1.32891e-06,1.32926e-06,1.32936e-06,1.32891e-06,1.32878e-06,1.33009e-06,1.32909e-06,1.32843e-06,1.32869e-06,1.329e-06,1.32922e-06,1.32873e-06,1.32925e-06,1.32935e-06,1.32868e-06,1.33182e-06,1.33036e-06,1.33152e-06,1.33102e-06,1.33156e-06,1.33107e-06,1.33204e-06,1.33183e-06,1.3316e-06,1.33108e-06,1.33242e-06,1.3313e-06,1.33178e-06,1.33121e-06,1.33254e-06,1.33089e-06,1.3316e-06,1.33154e-06,1.33149e-06,1.33206e-06,1.33158e-06,1.33179e-06,1.3318e-06,1.33182e-06,1.33139e-06,1.33064e-06,1.33169e-06,1.33095e-06,1.33156e-06,1.33154e-06,1.33169e-06,1.33127e-06,1.33578e-06,1.33464e-06,1.33525e-06,1.33491e-06,1.33515e-06,1.33606e-06,1.33598e-06,1.33593e-06,1.33588e-06,1.33588e-06,1.3358e-06,1.33624e-06,1.33506e-06,1.33549e-06,1.33576e-06,1.33497e-06,1.33676e-06,1.33624e-06,1.33659e-06,1.33712e-06,1.33723e-06,1.33698e-06,1.33759e-06,1.33746e-06,1.33738e-06,1.33718e-06,1.33781e-06,1.33727e-06,1.33793e-06,1.33682e-06,1.33879e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06,1.33701e-06},{1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31943e-06,1.31993e-06,1.31972e-06,1.32105e-06,1.32018e-06,1.32099e-06,1.32078e-06,1.32138e-06,1.32078e-06,1.32124e-06,1.32092e-06,1.32141e-06,1.32091e-06,1.32137e-06,1.32145e-06,1.3213e-06,1.3212e-06,1.32148e-06,1.32106e-06,1.32165e-06,1.32042e-06,1.32074e-06,1.32117e-06,1.32101e-06,1.32114e-06,1.32154e-06,1.32162e-06,1.32071e-06,1.32113e-06,1.32101e-06,1.3209e-06,1.32107e-06,1.32122e-06,1.32126e-06,1.32064e-06,1.32299e-06,1.32152e-06,1.32238e-06,1.32242e-06,1.32246e-06,1.32219e-06,1.32351e-06,1.32264e-06,1.32213e-06,1.32239e-06,1.32322e-06,1.32278e-06,1.32233e-06,1.32256e-06,1.32318e-06,1.32229e-06,1.32313e-06,1.32207e-06,1.32242e-06,1.32258e-06,1.32237e-06,1.32294e-06,1.32294e-06,1.32312e-06,1.32229e-06,1.32209e-06,1.32263e-06,1.3222e-06,1.32266e-06,1.32208e-06,1.32242e-06,1.32161e-06,1.32518e-06,1.32426e-06,1.3244e-06,1.3245e-06,1.32471e-06,1.32487e-06,1.32511e-06,1.32521e-06,1.32563e-06,1.32499e-06,1.3254e-06,1.32559e-06,1.32528e-06,1.32556e-06,1.32527e-06,1.32514e-06,1.3251e-06,1.32412e-06,1.32405e-06,1.32428e-06,1.32363e-06,1.32422e-06,1.32439e-06,1.32383e-06,1.32375e-06,1.32366e-06,1.32326e-06,1.32372e-06,1.32309e-06,1.32307e-06,1.3231e-06,1.3228e-06,1.32317e-06,1.32237e-06,1.32261e-06,1.32232e-06,1.32336e-06,1.32273e-06,1.32321e-06,1.32299e-06,1.32303e-06,1.32265e-06,1.32289e-06,1.32299e-06,1.32276e-06,1.32301e-06,1.32324e-06,1.32274e-06,1.32738e-06,1.32546e-06,1.32735e-06,1.32615e-06,1.32746e-06,1.32714e-06,1.3268e-06,1.32728e-06,1.32552e-06,1.32574e-06,1.32639e-06,1.325e-06,1.32605e-06,1.32552e-06,1.32559e-06,1.32496e-06,1.32676e-06,1.32557e-06,1.32599e-06,1.32609e-06,1.32594e-06,1.32528e-06,1.32677e-06,1.32565e-06,1.32581e-06,1.32559e-06,1.32606e-06,1.32611e-06,1.32541e-06,1.32572e-06,1.32674e-06,1.32575e-06,1.32629e-06,1.32617e-06,1.3266e-06,1.3269e-06,1.326e-06,1.32636e-06,1.32647e-06,1.32667e-06,1.32491e-06,1.3252e-06,1.32527e-06,1.32565e-06,1.32534e-06,1.32574e-06,1.32584e-06,1.3257e-06,1.33024e-06,1.32849e-06,1.32973e-06,1.32892e-06,1.32956e-06,1.32933e-06,1.33001e-06,1.32932e-06,1.32939e-06,1.32904e-06,1.33018e-06,1.32936e-06,1.3297e-06,1.32879e-06,1.33026e-06,1.32867e-06,1.32868e-06,1.32812e-06,1.32854e-06,1.32808e-06,1.32832e-06,1.32794e-06,1.32861e-06,1.32809e-06,1.32777e-06,1.3272e-06,1.32815e-06,1.32746e-06,1.32743e-06,1.32772e-06,1.32822e-06,1.32756e-06,1.33091e-06,1.3292e-06,1.33035e-06,1.32982e-06,1.33039e-06,1.32989e-06,1.32976e-06,1.33018e-06,1.3302e-06,1.32946e-06,1.33078e-06,1.33008e-06,1.33059e-06,1.33038e-06,1.331e-06,1.33003e-06,1.3324e-06,1.33072e-06,1.33137e-06,1.33257e-06,1.33135e-06,1.33179e-06,1.3321e-06,1.33135e-06,1.33066e-06,1.33026e-06,1.3312e-06,1.33074e-06,1.33095e-06,1.32963e-06,1.33134e-06,1.33019e-06,1.33181e-06,1.33193e-06,1.33191e-06,1.33158e-06,1.33146e-06,1.33181e-06,1.33162e-06,1.33174e-06,1.33135e-06,1.33119e-06,1.33121e-06,1.33156e-06,1.33152e-06,1.33225e-06,1.33325e-06,1.33243e-06,1.33452e-06,1.33239e-06,1.3339e-06,1.33253e-06,1.33233e-06,1.33319e-06,1.33265e-06,1.3322e-06,1.33169e-06,1.33172e-06,1.33166e-06,1.33211e-06,1.33149e-06,1.33189e-06,1.33197e-06,1.33167e-06,1.33655e-06,1.33558e-06,1.33651e-06,1.33619e-06,1.33646e-06,1.33604e-06,1.33634e-06,1.33609e-06,1.33701e-06,1.3358e-06,1.33688e-06,1.33618e-06,1.33694e-06,1.33638e-06,1.33782e-06,1.33632e-06,1.33924e-06,1.33664e-06,1.33964e-06,1.33806e-06,1.3385e-06,1.33815e-06,1.33831e-06,1.33843e-06,1.33749e-06,1.33758e-06,1.33886e-06,1.33768e-06,1.33828e-06,1.33755e-06,1.33906e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06,1.33731e-06}};

const Double_t L_abs[4][368] ={{1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44175e-06,1.44038e-06,1.4404e-06,1.44288e-06,1.44274e-06,1.44253e-06,1.4425e-06,1.44234e-06,1.4427e-06,1.4429e-06,1.4429e-06,1.44231e-06,1.44284e-06,1.4422e-06,1.4425e-06,1.44239e-06,1.44311e-06,1.44194e-06,1.44188e-06,1.44364e-06,1.44244e-06,1.44358e-06,1.44307e-06,1.44358e-06,1.44296e-06,1.444e-06,1.44345e-06,1.44234e-06,1.44217e-06,1.44235e-06,1.44221e-06,1.44141e-06,1.44254e-06,1.44141e-06,1.44098e-06,1.44388e-06,1.44207e-06,1.44331e-06,1.44249e-06,1.44312e-06,1.44309e-06,1.44285e-06,1.44307e-06,1.44264e-06,1.44316e-06,1.44244e-06,1.44279e-06,1.44334e-06,1.4424e-06,1.44277e-06,1.44179e-06,1.44484e-06,1.44445e-06,1.4447e-06,1.44417e-06,1.44431e-06,1.44413e-06,1.44465e-06,1.44449e-06,1.44339e-06,1.44287e-06,1.443e-06,1.44307e-06,1.44266e-06,1.44338e-06,1.44206e-06,1.44221e-06,1.44596e-06,1.44534e-06,1.44538e-06,1.44534e-06,1.44597e-06,1.44571e-06,1.44585e-06,1.44575e-06,1.44543e-06,1.44603e-06,1.44507e-06,1.44549e-06,1.44528e-06,1.44535e-06,1.44462e-06,1.4448e-06,1.44524e-06,1.44379e-06,1.44434e-06,1.44412e-06,1.44474e-06,1.44373e-06,1.44432e-06,1.44459e-06,1.4434e-06,1.4431e-06,1.4438e-06,1.44329e-06,1.44377e-06,1.44346e-06,1.44359e-06,1.44325e-06,1.44571e-06,1.44379e-06,1.44549e-06,1.44428e-06,1.44528e-06,1.44468e-06,1.44476e-06,1.44527e-06,1.44505e-06,1.44513e-06,1.44544e-06,1.44533e-06,1.44556e-06,1.44575e-06,1.44578e-06,1.44485e-06,1.44708e-06,1.44652e-06,1.4461e-06,1.44729e-06,1.44672e-06,1.44671e-06,1.44703e-06,1.44708e-06,1.44554e-06,1.44555e-06,1.44615e-06,1.44553e-06,1.44539e-06,1.44608e-06,1.44569e-06,1.44498e-06,1.44685e-06,1.44566e-06,1.44593e-06,1.44592e-06,1.44626e-06,1.44595e-06,1.44667e-06,1.44624e-06,1.44596e-06,1.44623e-06,1.44638e-06,1.44654e-06,1.446e-06,1.4463e-06,1.44639e-06,1.44581e-06,1.44704e-06,1.44655e-06,1.44711e-06,1.44659e-06,1.44736e-06,1.44691e-06,1.44678e-06,1.44722e-06,1.44621e-06,1.4461e-06,1.44697e-06,1.44615e-06,1.44655e-06,1.44683e-06,1.44671e-06,1.44596e-06,1.45181e-06,1.45104e-06,1.4512e-06,1.45145e-06,1.45147e-06,1.45109e-06,1.45154e-06,1.45143e-06,1.45104e-06,1.45099e-06,1.45194e-06,1.45102e-06,1.45068e-06,1.45126e-06,1.45069e-06,1.45038e-06,1.4518e-06,1.44897e-06,1.45117e-06,1.45013e-06,1.45101e-06,1.45012e-06,1.45027e-06,1.45038e-06,1.44995e-06,1.44976e-06,1.45026e-06,1.449e-06,1.44951e-06,1.44977e-06,1.44944e-06,1.44888e-06,1.45185e-06,1.4495e-06,1.45143e-06,1.45002e-06,1.45131e-06,1.45076e-06,1.45036e-06,1.45109e-06,1.45095e-06,1.4504e-06,1.45099e-06,1.45086e-06,1.45107e-06,1.4508e-06,1.45114e-06,1.4507e-06,1.45059e-06,1.45024e-06,1.4503e-06,1.4505e-06,1.45037e-06,1.45101e-06,1.45056e-06,1.45094e-06,1.45004e-06,1.44977e-06,1.45024e-06,1.4499e-06,1.44992e-06,1.45017e-06,1.45042e-06,1.45e-06,1.45383e-06,1.45264e-06,1.454e-06,1.45337e-06,1.45367e-06,1.45366e-06,1.45352e-06,1.45422e-06,1.45346e-06,1.45347e-06,1.4534e-06,1.45348e-06,1.45301e-06,1.45343e-06,1.4526e-06,1.45295e-06,1.45317e-06,1.45349e-06,1.45308e-06,1.45366e-06,1.45425e-06,1.45359e-06,1.45394e-06,1.45384e-06,1.45324e-06,1.45309e-06,1.45304e-06,1.45296e-06,1.45251e-06,1.45335e-06,1.45221e-06,1.45287e-06,1.45575e-06,1.45417e-06,1.45511e-06,1.45581e-06,1.45556e-06,1.45583e-06,1.45577e-06,1.45605e-06,1.45623e-06,1.45601e-06,1.45673e-06,1.45706e-06,1.45663e-06,1.4559e-06,1.45741e-06,1.456e-06,1.45687e-06,1.45559e-06,1.45639e-06,1.45661e-06,1.4574e-06,1.45685e-06,1.45716e-06,1.45793e-06,1.45767e-06,1.45736e-06,1.45786e-06,1.45773e-06,1.45751e-06,1.45764e-06,1.45766e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06,1.45788e-06},{1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44186e-06,1.44155e-06,1.44101e-06,1.44378e-06,1.44234e-06,1.44321e-06,1.44293e-06,1.44337e-06,1.44275e-06,1.44349e-06,1.44325e-06,1.4429e-06,1.44231e-06,1.44348e-06,1.44276e-06,1.44328e-06,1.44298e-06,1.4436e-06,1.44268e-06,1.44455e-06,1.44329e-06,1.44501e-06,1.44332e-06,1.44443e-06,1.44348e-06,1.44397e-06,1.44406e-06,1.44302e-06,1.44313e-06,1.44349e-06,1.44307e-06,1.44347e-06,1.44231e-06,1.44342e-06,1.44217e-06,1.44479e-06,1.4435e-06,1.4447e-06,1.44371e-06,1.44475e-06,1.44412e-06,1.44443e-06,1.44434e-06,1.44424e-06,1.44397e-06,1.44449e-06,1.44425e-06,1.44451e-06,1.44403e-06,1.4445e-06,1.44381e-06,1.44556e-06,1.44433e-06,1.44556e-06,1.44497e-06,1.44556e-06,1.44516e-06,1.44498e-06,1.44531e-06,1.44434e-06,1.44336e-06,1.44415e-06,1.44368e-06,1.44379e-06,1.44377e-06,1.44393e-06,1.44319e-06,1.448e-06,1.44691e-06,1.4476e-06,1.44696e-06,1.44751e-06,1.44733e-06,1.4471e-06,1.44817e-06,1.44775e-06,1.44764e-06,1.448e-06,1.44769e-06,1.44757e-06,1.44746e-06,1.44781e-06,1.44666e-06,1.44783e-06,1.44653e-06,1.44724e-06,1.44722e-06,1.44779e-06,1.4474e-06,1.44764e-06,1.44803e-06,1.4469e-06,1.4459e-06,1.44733e-06,1.44595e-06,1.44672e-06,1.44685e-06,1.4472e-06,1.44671e-06,1.44873e-06,1.44787e-06,1.44838e-06,1.44827e-06,1.44931e-06,1.44838e-06,1.44872e-06,1.44886e-06,1.4487e-06,1.44796e-06,1.44884e-06,1.44822e-06,1.44863e-06,1.4486e-06,1.44859e-06,1.4484e-06,1.44935e-06,1.44793e-06,1.44897e-06,1.44888e-06,1.4493e-06,1.4484e-06,1.44906e-06,1.44908e-06,1.44823e-06,1.44815e-06,1.44911e-06,1.44842e-06,1.44869e-06,1.44881e-06,1.4488e-06,1.44835e-06,1.45154e-06,1.45079e-06,1.4514e-06,1.45165e-06,1.45133e-06,1.45121e-06,1.45138e-06,1.4512e-06,1.45066e-06,1.45085e-06,1.4504e-06,1.45042e-06,1.45043e-06,1.45082e-06,1.45022e-06,1.45058e-06,1.45123e-06,1.44965e-06,1.45087e-06,1.45054e-06,1.45064e-06,1.45003e-06,1.45135e-06,1.45033e-06,1.45041e-06,1.44955e-06,1.45058e-06,1.44979e-06,1.44994e-06,1.44985e-06,1.45074e-06,1.44924e-06,1.45408e-06,1.45334e-06,1.45293e-06,1.45408e-06,1.4535e-06,1.45329e-06,1.45347e-06,1.45315e-06,1.45373e-06,1.45305e-06,1.45391e-06,1.45362e-06,1.45372e-06,1.4531e-06,1.45393e-06,1.45314e-06,1.45312e-06,1.4529e-06,1.45319e-06,1.4529e-06,1.45344e-06,1.45298e-06,1.45333e-06,1.45391e-06,1.45334e-06,1.45259e-06,1.45354e-06,1.4525e-06,1.4527e-06,1.45207e-06,1.45281e-06,1.45161e-06,1.45445e-06,1.45271e-06,1.45374e-06,1.45372e-06,1.45379e-06,1.45391e-06,1.45443e-06,1.45395e-06,1.45485e-06,1.4542e-06,1.45469e-06,1.45445e-06,1.4542e-06,1.45434e-06,1.45431e-06,1.45435e-06,1.45614e-06,1.45511e-06,1.45596e-06,1.45574e-06,1.45615e-06,1.45549e-06,1.45529e-06,1.45604e-06,1.455e-06,1.45541e-06,1.45532e-06,1.4551e-06,1.45531e-06,1.45511e-06,1.45516e-06,1.45481e-06,1.45802e-06,1.45641e-06,1.45717e-06,1.45737e-06,1.45848e-06,1.45734e-06,1.45818e-06,1.45808e-06,1.45808e-06,1.45819e-06,1.45769e-06,1.458e-06,1.45765e-06,1.45792e-06,1.45782e-06,1.45738e-06,1.45911e-06,1.45766e-06,1.45897e-06,1.45925e-06,1.45882e-06,1.45988e-06,1.45934e-06,1.45953e-06,1.4585e-06,1.45892e-06,1.45805e-06,1.45809e-06,1.45828e-06,1.45755e-06,1.45818e-06,1.45818e-06,1.46144e-06,1.4611e-06,1.46139e-06,1.4623e-06,1.46173e-06,1.4625e-06,1.46195e-06,1.46243e-06,1.46148e-06,1.46259e-06,1.46167e-06,1.46242e-06,1.46253e-06,1.46245e-06,1.46272e-06,1.46212e-06,1.46283e-06,1.46127e-06,1.46212e-06,1.46254e-06,1.46289e-06,1.46241e-06,1.46223e-06,1.4632e-06,1.46216e-06,1.46286e-06,1.46256e-06,1.46301e-06,1.46253e-06,1.46252e-06,1.46202e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06,1.46136e-06},{1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43857e-06,1.43899e-06,1.43806e-06,1.43993e-06,1.43907e-06,1.43961e-06,1.43945e-06,1.43987e-06,1.43988e-06,1.44017e-06,1.43989e-06,1.4399e-06,1.43998e-06,1.44024e-06,1.44057e-06,1.44048e-06,1.44159e-06,1.44106e-06,1.43937e-06,1.4406e-06,1.44013e-06,1.44056e-06,1.4403e-06,1.44018e-06,1.44016e-06,1.44087e-06,1.44052e-06,1.43916e-06,1.4399e-06,1.4397e-06,1.44012e-06,1.43974e-06,1.43993e-06,1.44054e-06,1.4395e-06,1.44173e-06,1.44111e-06,1.4414e-06,1.44134e-06,1.4406e-06,1.44088e-06,1.44105e-06,1.44083e-06,1.4405e-06,1.4407e-06,1.44057e-06,1.44082e-06,1.44023e-06,1.44076e-06,1.44106e-06,1.43982e-06,1.43956e-06,1.43954e-06,1.43994e-06,1.4393e-06,1.43941e-06,1.44003e-06,1.43983e-06,1.43963e-06,1.43861e-06,1.43903e-06,1.43889e-06,1.43878e-06,1.43897e-06,1.4384e-06,1.43933e-06,1.43827e-06,1.44542e-06,1.44513e-06,1.44534e-06,1.44522e-06,1.44498e-06,1.44498e-06,1.44494e-06,1.44495e-06,1.44457e-06,1.44485e-06,1.44426e-06,1.44447e-06,1.44419e-06,1.44449e-06,1.44394e-06,1.44372e-06,1.4441e-06,1.44269e-06,1.44356e-06,1.44297e-06,1.44375e-06,1.44301e-06,1.44274e-06,1.44393e-06,1.44311e-06,1.4425e-06,1.44304e-06,1.44266e-06,1.44277e-06,1.44287e-06,1.44296e-06,1.44234e-06,1.44417e-06,1.44328e-06,1.44393e-06,1.44319e-06,1.44424e-06,1.44388e-06,1.44379e-06,1.44386e-06,1.44438e-06,1.44409e-06,1.44502e-06,1.44436e-06,1.44451e-06,1.44431e-06,1.44435e-06,1.44404e-06,1.44432e-06,1.44297e-06,1.44456e-06,1.44382e-06,1.44469e-06,1.44485e-06,1.44414e-06,1.44502e-06,1.44434e-06,1.44396e-06,1.44426e-06,1.44403e-06,1.44391e-06,1.44407e-06,1.44406e-06,1.44318e-06,1.44635e-06,1.4462e-06,1.44603e-06,1.44628e-06,1.4472e-06,1.44666e-06,1.44687e-06,1.44726e-06,1.44628e-06,1.44686e-06,1.44628e-06,1.44621e-06,1.44641e-06,1.44687e-06,1.44671e-06,1.44585e-06,1.44698e-06,1.44762e-06,1.44678e-06,1.44763e-06,1.44721e-06,1.44751e-06,1.44799e-06,1.44769e-06,1.44678e-06,1.44703e-06,1.44654e-06,1.44659e-06,1.44647e-06,1.44733e-06,1.44627e-06,1.44642e-06,1.44909e-06,1.4473e-06,1.44878e-06,1.44779e-06,1.44879e-06,1.44831e-06,1.44828e-06,1.44876e-06,1.44886e-06,1.44781e-06,1.44893e-06,1.4481e-06,1.44884e-06,1.44871e-06,1.44878e-06,1.44839e-06,1.45061e-06,1.4501e-06,1.45011e-06,1.45006e-06,1.4505e-06,1.45024e-06,1.45028e-06,1.45008e-06,1.44993e-06,1.44989e-06,1.44932e-06,1.44958e-06,1.44837e-06,1.44956e-06,1.44874e-06,1.44852e-06,1.4503e-06,1.45125e-06,1.45028e-06,1.45135e-06,1.45134e-06,1.45095e-06,1.45179e-06,1.45173e-06,1.45172e-06,1.4517e-06,1.45207e-06,1.45184e-06,1.45096e-06,1.4522e-06,1.45114e-06,1.45124e-06,1.45163e-06,1.45084e-06,1.45103e-06,1.45207e-06,1.45104e-06,1.45073e-06,1.45178e-06,1.45126e-06,1.45064e-06,1.45029e-06,1.45064e-06,1.45038e-06,1.44983e-06,1.45039e-06,1.45004e-06,1.45002e-06,1.45191e-06,1.45083e-06,1.45189e-06,1.45131e-06,1.45207e-06,1.45142e-06,1.45116e-06,1.45184e-06,1.45184e-06,1.45124e-06,1.45164e-06,1.45141e-06,1.45206e-06,1.45153e-06,1.45196e-06,1.4514e-06,1.45237e-06,1.45174e-06,1.45176e-06,1.45236e-06,1.45204e-06,1.45283e-06,1.45208e-06,1.45287e-06,1.45089e-06,1.45139e-06,1.4514e-06,1.4507e-06,1.45183e-06,1.45188e-06,1.4516e-06,1.4516e-06,1.45652e-06,1.45541e-06,1.45623e-06,1.45632e-06,1.45589e-06,1.45639e-06,1.45585e-06,1.45649e-06,1.45613e-06,1.45627e-06,1.45586e-06,1.45616e-06,1.45613e-06,1.4561e-06,1.45526e-06,1.45573e-06,1.45559e-06,1.45416e-06,1.45541e-06,1.45491e-06,1.45625e-06,1.45511e-06,1.45533e-06,1.45602e-06,1.45556e-06,1.45561e-06,1.4553e-06,1.45603e-06,1.4555e-06,1.45566e-06,1.45605e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06,1.45597e-06},{1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44148e-06,1.44207e-06,1.44107e-06,1.4444e-06,1.44285e-06,1.44417e-06,1.44333e-06,1.44391e-06,1.44356e-06,1.44323e-06,1.44335e-06,1.44354e-06,1.44294e-06,1.44363e-06,1.44271e-06,1.44413e-06,1.44298e-06,1.44341e-06,1.44303e-06,1.44384e-06,1.4426e-06,1.44355e-06,1.44278e-06,1.44302e-06,1.44337e-06,1.44298e-06,1.44345e-06,1.44205e-06,1.44197e-06,1.44262e-06,1.4423e-06,1.4421e-06,1.44221e-06,1.44265e-06,1.44152e-06,1.4439e-06,1.44262e-06,1.44387e-06,1.44312e-06,1.44387e-06,1.44345e-06,1.44414e-06,1.44369e-06,1.44365e-06,1.44347e-06,1.44443e-06,1.44353e-06,1.44395e-06,1.44419e-06,1.44404e-06,1.44331e-06,1.44475e-06,1.4434e-06,1.44409e-06,1.44384e-06,1.44443e-06,1.44398e-06,1.44455e-06,1.44456e-06,1.44385e-06,1.44292e-06,1.44454e-06,1.44314e-06,1.44372e-06,1.44347e-06,1.44401e-06,1.44251e-06,1.44797e-06,1.44637e-06,1.44716e-06,1.44672e-06,1.44705e-06,1.44712e-06,1.44656e-06,1.44692e-06,1.44687e-06,1.44635e-06,1.44642e-06,1.44692e-06,1.44666e-06,1.44648e-06,1.44662e-06,1.44617e-06,1.4473e-06,1.44557e-06,1.44656e-06,1.44596e-06,1.44687e-06,1.44505e-06,1.44657e-06,1.44604e-06,1.44498e-06,1.44489e-06,1.44557e-06,1.44481e-06,1.44581e-06,1.44501e-06,1.44612e-06,1.44432e-06,1.44687e-06,1.44573e-06,1.44572e-06,1.44606e-06,1.44662e-06,1.4463e-06,1.44583e-06,1.44639e-06,1.44648e-06,1.44627e-06,1.44695e-06,1.4463e-06,1.44655e-06,1.44711e-06,1.44685e-06,1.44656e-06,1.44803e-06,1.44722e-06,1.44801e-06,1.44756e-06,1.44835e-06,1.44757e-06,1.44846e-06,1.4482e-06,1.44755e-06,1.44692e-06,1.44745e-06,1.44675e-06,1.44743e-06,1.44671e-06,1.44777e-06,1.44626e-06,1.44907e-06,1.44776e-06,1.44884e-06,1.44851e-06,1.44903e-06,1.44882e-06,1.44886e-06,1.44876e-06,1.44879e-06,1.44867e-06,1.44908e-06,1.44883e-06,1.4489e-06,1.44874e-06,1.44891e-06,1.44839e-06,1.4491e-06,1.44882e-06,1.44932e-06,1.44875e-06,1.44977e-06,1.44915e-06,1.44916e-06,1.44979e-06,1.44899e-06,1.44809e-06,1.44919e-06,1.44833e-06,1.44917e-06,1.4483e-06,1.44933e-06,1.44797e-06,1.45218e-06,1.45087e-06,1.45249e-06,1.45106e-06,1.45204e-06,1.45192e-06,1.45188e-06,1.45188e-06,1.45232e-06,1.45149e-06,1.45252e-06,1.45166e-06,1.45216e-06,1.45224e-06,1.45211e-06,1.45151e-06,1.45268e-06,1.45132e-06,1.45151e-06,1.45172e-06,1.452e-06,1.45147e-06,1.45186e-06,1.45241e-06,1.4513e-06,1.45086e-06,1.45164e-06,1.45121e-06,1.45151e-06,1.45123e-06,1.45144e-06,1.45057e-06,1.45246e-06,1.45243e-06,1.45199e-06,1.45258e-06,1.45277e-06,1.45188e-06,1.45306e-06,1.45222e-06,1.45317e-06,1.45241e-06,1.45338e-06,1.45252e-06,1.45303e-06,1.45237e-06,1.45328e-06,1.45238e-06,1.45386e-06,1.45313e-06,1.45371e-06,1.45354e-06,1.4538e-06,1.45324e-06,1.45279e-06,1.45394e-06,1.45244e-06,1.4534e-06,1.45302e-06,1.45312e-06,1.45345e-06,1.45315e-06,1.4532e-06,1.45288e-06,1.45434e-06,1.45293e-06,1.45477e-06,1.45396e-06,1.45461e-06,1.4548e-06,1.45418e-06,1.45492e-06,1.45451e-06,1.45416e-06,1.45505e-06,1.45442e-06,1.45429e-06,1.45465e-06,1.45481e-06,1.45385e-06,1.45565e-06,1.45403e-06,1.4552e-06,1.45523e-06,1.45546e-06,1.45538e-06,1.45538e-06,1.45564e-06,1.45447e-06,1.45406e-06,1.45489e-06,1.45391e-06,1.45458e-06,1.45393e-06,1.45486e-06,1.45403e-06,1.45915e-06,1.45755e-06,1.45866e-06,1.45835e-06,1.45876e-06,1.45921e-06,1.45821e-06,1.4592e-06,1.45903e-06,1.45847e-06,1.45907e-06,1.45897e-06,1.45881e-06,1.45896e-06,1.45898e-06,1.4586e-06,1.45912e-06,1.4579e-06,1.4589e-06,1.45903e-06,1.45961e-06,1.4597e-06,1.46001e-06,1.46014e-06,1.46007e-06,1.45994e-06,1.46048e-06,1.4596e-06,1.46029e-06,1.45988e-06,1.46019e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06,1.45979e-06}};

#define DEBUG false

const Double_t Right_R[16] 
= {2551.36, 2550.84, 2552.93, 2552.42, 2553.03, 2553.02, 2552.42, 2553.06, 2555.18, 2553.52, 2554.33, 2552.95, 2549.92, 2550.57, 2551.83, 2548.26};

const Double_t Right_L[16] 
= {2553.56, 2547.79, 2550.14, 2549.62, 2552.32, 2549.35, 2554.73, 2552.29, 2550.83, 2547.63, 2551.22, 2551.11, 2552.26, 2549.53, 2548.21, 2551.16};

const Double_t Left_R[16] 
= {2759.06, 2820.8, 2815.81, 2819.58, 2821.29, 2818.89, 2821.84, 2821.3, 2821.87, 2822.54, 2822.36, 2821.5, 2820.98, 2821.42, 2820.59, 2759.86};

const Double_t Left_L[16] 
= {2817.96, 2760.24, 2763.8, 2760.99, 2764.22, 2764.18, 2765.38, 2767.82, 2764.86, 2763.6, 2764.22, 2758.28, 2759.5, 2759.49, 2763.37, 2821.76};


//some hard-coded APEX values, that do not change for any run-number
const int VDC_nPlanes = 4; 
const int VDC_nWires  = 368; 

//w-value of each plane (equivalent to det-coords z-value)
const double VDC_w_R[VDC_nPlanes] = { 0, 0.026, 0.333245, 0.359245 };
const double VDC_w_L[VDC_nPlanes] = { 0, 0.026, 0.335344, 0.361444 };

//positions of first-wires
const double VDC_wire0_R[VDC_nPlanes] = { 0.77852, 0.77852, 1.02793, 1.02793 }; 
const double VDC_wire0_L[VDC_nPlanes] = { 0.77852, 0.77852, 1.02718, 1.02718 }; 

double THRS::VDC::offset_RHRS[THRS::VDC::fN_PLANES][THRS::VDC::fN_WIRES];
double THRS::VDC::offset_LHRS[THRS::VDC::fN_PLANES][THRS::VDC::fN_WIRES];

THRS::VDC::InitStatus THRS::VDC::status_RHRS[4] = { THRS::VDC::NotInit }; 
THRS::VDC::InitStatus THRS::VDC::status_LHRS[4] = { THRS::VDC::NotInit }; 


map<THRS::MatrixType,THRS::TMatrix*> THRS::fMatrixMap_R{ 
  {THRS::Mat_fp_y,     new THRS::TMatrix(THRS::Mat_fp_y)},
  {THRS::Mat_tan_rho,  new THRS::TMatrix(THRS::Mat_tan_rho)},
  {THRS::Mat_fp_phi,   new THRS::TMatrix(THRS::Mat_fp_phi)},
  {THRS::Mat_tg_y,     new THRS::TMatrix(THRS::Mat_tg_y)},
  {THRS::Mat_tg_theta, new THRS::TMatrix(THRS::Mat_tg_theta)},
  {THRS::Mat_tg_phi,   new THRS::TMatrix(THRS::Mat_tg_phi)},
  {THRS::Mat_tg_dp,    new THRS::TMatrix(THRS::Mat_tg_dp)} }; 
    
map<THRS::MatrixType,THRS::TMatrix*> THRS::fMatrixMap_L{ 
  {THRS::Mat_fp_y,     new THRS::TMatrix(THRS::Mat_fp_y)},
  {THRS::Mat_tan_rho,  new THRS::TMatrix(THRS::Mat_tan_rho)},
  {THRS::Mat_fp_phi,   new THRS::TMatrix(THRS::Mat_fp_phi)},
  {THRS::Mat_tg_y,     new THRS::TMatrix(THRS::Mat_tg_y)},
  {THRS::Mat_tg_theta, new THRS::TMatrix(THRS::Mat_tg_theta)},
  {THRS::Mat_tg_phi,   new THRS::TMatrix(THRS::Mat_tg_phi)},
  {THRS::Mat_tg_dp,    new THRS::TMatrix(THRS::Mat_tg_dp)} }; 

THRS::HRS_initStatus THRS::OpticsStatus_RHRS = THRS::Init_notDone;
THRS::HRS_initStatus THRS::OpticsStatus_LHRS = THRS::Init_notDone;


////////////////////////////////////////////////////////////////////////////////////
void THRS::Parse_opticsData( const bool arm, const TString path_DB ) { 
  
  map<TString,MatrixType> typeNames{ 
    {"t",Mat_tan_rho}, 
    {"y",Mat_fp_y}, 
    {"p",Mat_fp_phi}, 
    {"D",Mat_tg_dp}, 
    {"T",Mat_tg_theta}, 
    {"P",Mat_tg_phi}, 
    {"Y",Mat_tg_y}     }; 
     

  const int N_exponent =3; 
  const int N_poly     =7; 
  
  const double minVal = 1e-30; 
  
  const TString here = "THRS::Parse_opticsData(TString)"; 
    
  cout << TString::Format("%s => parsing data from \"%s\"...",
			  here.Data(),
			  path_DB.Data()) 
       << flush; 
  
  fstream db; db.open( path_DB.Data(), ios::in );   
  
  //failed to open file! 
  if (!db) { 
    THRS::ReportError(here,"File could not be opened!"); 
    return; 
  }
    
  TString str; 
    
  while ( !db.eof() ) { 
    
    //let's find which element we're working with..
    db >> str; 
    
    //we've reached the end of the file
    if (str=="eof") { 
      if (arm==THRS::Arm_Right) { THRS::OpticsStatus_RHRS = Init_ok; }
      else                      { THRS::OpticsStatus_LHRS = Init_ok; }
      break; 
    }
    
    const TString name = str; 
    
    //check to see if the one-letter 'name' is actually a valid matrix name    
    auto findName = typeNames.find(name); 
    
    if (findName == typeNames.end()) {  
      
      if (arm==THRS::Arm_Right) { THRS::OpticsStatus_RHRS = Init_error; }
      else                      { THRS::OpticsStatus_LHRS = Init_error; }
      
      THRS::ReportError(here,"Invalid type read from optics file"); 
      return; 
    }
    
    MatrixType type = findName->second; 
    
    
    auto elem = new TMatrixElement(type); 
    
    for (int p=0; p<N_exponent; p++) { db >> str; elem->fExp[p] = atoi(str); }
    
    //now, get the polynomials
    for (int p=0; p<N_poly; p++) { 
      
      db >> str; double val = stod((string)str); 
      
      elem->fPoly.push_back(val); 
    }
    
    //check for 0-values on the end of the polynomial
    for (int p=elem->fPoly.size()-1; p>=0; p--) { 
      
      double val = elem->fPoly.at(p);  
      
      if (TMath::Abs(val) < minVal) { elem->fPoly.erase( elem->fPoly.begin()+p ); }
      else { break; }
    }
    
    
    //this extra 'int' on the end of each line, idk what it's for
    //UPDATE: I think this last power is powers in (fExp); 
    db >> str; elem->fExp[3] = atoi(str); 
        
    //check size of the polynomial
    if (elem->fPoly.size()==0) { 
      cout << here << " => zero poly. elems. found." << endl; 
      elem->~TMatrixElement(); 
      continue; 
    }			    
    
    auto matrix = (arm==THRS::Arm_Right) 
      ? THRS::fMatrixMap_R.find(type)->second 
      : THRS::fMatrixMap_L.find(type)->second; 
      
    matrix->fElems.push_back( elem ); 
    //now, add this element to its respective matrix
    
    //check which arm we're looking at
  }  
  
  //fill out what 'powers' we need for each computation of target variables
  
}
bool THRS::PrintStatus_optics() { 
  
  bool good=true; 
  
  map<MatrixType,TString> matrix_names{ 
    {Mat_tan_rho,  "tan_rho"},
    {Mat_fp_y,     "fp_y"},
    {Mat_fp_phi,   "fp_phi"}, 
    {Mat_tg_dp,    "tg_dp"}, 
    {Mat_tg_theta, "tg_theta"}, 
    {Mat_tg_phi,   "tg_phi"}, 
    {Mat_tg_y,     "tg_y"} }; 
  
  const TString here = "THRS::Print_matrixStatus()"; 
  
  //check all matricies that should exist
  vector<MatrixType> matrices{ 
    Mat_fp_y, 
    Mat_tan_rho, 
    Mat_fp_phi, 
    Mat_tg_y,
    Mat_tg_theta,
    Mat_tg_phi,
    Mat_tg_dp };  
  
  cout << here << " => Checking status of optics matricies.." << endl; 
  
  cout << "RHRS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl; 
  for (UInt_t m=0; m<matrices.size(); m++) { 
    
    auto m_it = THRS::fMatrixMap_R.find( matrices.at(m) ); 
    
    auto matrix = m_it->second; 
    
    TString name = matrix_names.find(matrices.at(m))->second; 
    
    cout << TString::Format("Matrix '%s', nElems=%2i", 
			    name.Data(), 
			    (int)matrix->fElems.size() ) << endl; 
  }
  
  cout << "overall status = "; 
  switch (THRS::OpticsStatus_RHRS) 
    { 
    case THRS::Init_ok      : cout << "Ok" << endl; break; 
    case THRS::Init_notDone : cout << "Not initialized" << endl; good=false; break; 
    case THRS::Init_error   : cout << "Error!" << endl;          good=false; break; 
    }
  
  
  cout << "LHRS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl; 
  for (UInt_t m=0; m<matrices.size(); m++) { 
    
    auto m_it = THRS::fMatrixMap_L.find( matrices.at(m) ); 
    
    auto matrix = m_it->second; 
    
    TString name = matrix_names.find(matrices.at(m))->second; 
    
    cout << TString::Format("Matrix '%s', nElems=%2i", 
			    name.Data(), 
			    (int)matrix->fElems.size() ) << endl; 
  }
  
  cout << "overall status = "; 
  switch (THRS::OpticsStatus_LHRS) 
    { 
    case THRS::Init_ok      : cout << "Ok" << endl; break; 
    case THRS::Init_notDone : cout << "Not initialized" << endl; good=false; break; 
    case THRS::Init_error   : cout << "Error!" << endl;          good=false; break; 
    }
  
  return good; 
}
////////////////////////////////////////////////////////////////////////////////////
double THRS::TMatrixElement::Evaluate_poly( const double x_fp ) const { 
  
  const TString here = "THRS::TMatrixElement::Evaluate_poly()"; 
    
  double val=0.0; 
  
  for (int p=fPoly.size()-1; p>=0; p--) { val = val*x_fp + fPoly.at(p); }
  
  return val; 
}
////////////////////////////////////////////////////////////////////////////////////
double THRS::TMatrix::Evaluate( const double fp_x, 
				const double fp_y[fMatrix_MAX_EXP], 
				const double fp_theta[fMatrix_MAX_EXP], 
				const double fp_phi[fMatrix_MAX_EXP]    ) const { 
  
#if DEBUG
  cout << "THRS::TMatrix::Evaluate() - matrix n.=" << fType << endl; 
  
  cout << TString::Format("inputs = [x=%0.3e, y=%0.3e, th=%0.3e, ph=%0.3e]", 
			  fp_x, fp_y[0], fp_theta[0], fp_phi[0]) << endl; 
#endif   

  bool is_fpMatrix = fElems.size()==1; 
  
  double val = 0.;
  
  for (UInt_t i=0; i<fElems.size(); i++) { 
    
    TMatrixElement *elem = fElems.at(i); 
    
    //compute the x-fp polynomial of this element
    double Ei = elem->Evaluate_poly( fp_x ); 
    
    if (is_fpMatrix) return Ei; 
    
#if DEBUG 
    cout << TString::Format("elem-(%2i), exp=[%i,%i,%i,%i], poly=[%0.3e], ", 
			    (int)i, 
			    elem->fExp[0],elem->fExp[1],elem->fExp[2],elem->fExp[3],
			    Ei); 
#endif 
    
    //if this ISN'T a fp-matrx, then we will add the powers of the other vars
    if (elem->fExp[0]>0) Ei *= fp_theta[elem->fExp[0]-1]; 
    if (elem->fExp[1]>0) Ei *= fp_y    [elem->fExp[1]-1]; 
    if (elem->fExp[2]>0) Ei *= fp_phi  [elem->fExp[2]-1]; 
    
    //if (elem->fExp[3]>0) Ei *= TMath::Abs(fp_theta[elem->fExp[3]-1]); 
    
#if DEBUG 
    cout << TString::Format("M=[%0.3e]", Ei) << endl; 
#endif 
    
    val += Ei;
  }

#if DEBUG 
    cout << TString::Format("final val = %0.3e, ", val) << endl; 
#endif 
    
  
  return val; 
}
double THRS::TMatrix::Evaluate( const double fp_x ) const { 
  
  //same as above, but for single-element fp-matrices
  const TString here = "THRS::Evaluate()";   
  
  if (fElems.size()!=1) { 
    THRS::ReportError(here,"This is not a FP matrix!"); 
    return -1e30; 
  }
    
  return fElems.at(0)->Evaluate_poly( fp_x );
}
void THRS::Compute_trackOptics( const bool arm, 
				const double x_tr, 
				const double y_tr, 
				const double dxdz,
				const double dydz, 
				double &tg_y,
				double &tg_dxdz, 
				double &tg_dydz, 
				double &tg_dp    ) { 
  
  //compute the 'focal plane' coordinates of the track, as well as the target 
  // coordinates. 
  // These computations are informed mainly by John Williamson's thesis
  // 'APEX (A'Epxeriment): The Search for a Dark Photon at Jefferson Lab' (2022), 
  // specifically, see section 3.5.5 as well as section 4.5.  
  
  const TString here = "THRS::Compute_trackOptics()"; 
  
  //check optics status 
  HRS_initStatus optics_status = arm 
    ? THRS::OpticsStatus_RHRS : THRS::OpticsStatus_LHRS; 
  
  switch (optics_status) 
    { 
    case Init_ok     : break; //init status ok 

    case Init_notDone: 
      THRS::ReportError(here,"Optics not initalized."); 
      return; 
    case Init_error  : 
      THRS::ReportError(here,"Problem with optics init."); 
      return; 
    default          :
      THRS::ReportError(here,"Unknown error with optics init."); 
      return; 
    }
  
  //get optics matrix-map 
  map<MatrixType,TMatrix*> matMap = arm ? THRS::fMatrixMap_R : THRS::fMatrixMap_L; 
  
  double fp_x = x_tr; 
  
  double fp_y[TMatrix::fMatrix_MAX_EXP+1]; 
  double fp_theta[TMatrix::fMatrix_MAX_EXP+1]; 
  double fp_phi[TMatrix::fMatrix_MAX_EXP+1]; 
    
  //focal-plane y
  //note: these 'fp-matrices' are only polynomials in powers of 'fp_x'
  fp_y[0] = y_tr - matMap.find( Mat_fp_y )->second->Evaluate( fp_x ); 
  
  //get tan(rho), which is the 'local central ray' of particles
  double tan_rho = matMap.find( Mat_tan_rho )->second->Evaluate( fp_x ); 
  
  double cos_rho = 1./TMath::Sqrt( 1. + tan_rho*tan_rho ); 
  
  //now, compute fp_theta & fp_phi (first order)
  fp_theta[0] = (dxdz + tan_rho)/(1. - dxdz*tan_rho); 
    
  fp_phi[0] 
    = ( dydz - matMap.find( Mat_fp_phi )->second->Evaluate( fp_x ) )
    / (1. - dxdz*tan_rho) / cos_rho;   
    
  //we've now evaluated all of our focal-plane coords. let's find their higher-pow's
  for (int p=2; p<=TMatrix::fMatrix_MAX_EXP; p++) { 
    
    fp_y[p-1]     = pow( fp_y[0],     p ); 
    fp_theta[p-1] = pow( fp_theta[0], p ); 
    fp_phi[p-1]   = pow( fp_phi[0],   p ); 
  }
  
  //now, we're ready to evaluate target-coords. 
  //target_y
  tg_y    = matMap.find( Mat_tg_y     )->second->Evaluate( fp_x, 
							   fp_y, 
							   fp_theta, 
							   fp_phi ); 
  //target_theta
  tg_dxdz = matMap.find( Mat_tg_theta )->second->Evaluate( fp_x, 
							   fp_y, 
							   fp_theta, 
							   fp_phi ); 
  //target_phi
  tg_dydz = matMap.find( Mat_tg_phi   )->second->Evaluate( fp_x, 
							   fp_y, 
							   fp_theta, 
							   fp_phi ); 
  //target_dp
  tg_dp   = matMap.find( Mat_tg_dp    )->second->Evaluate( fp_x, 
							   fp_y, 
							   fp_theta, 
							   fp_phi ); 
}
////////////////////////////////////////////////////////////////////////////////////
void THRS::ReportError( const TString location, 
			const TString message ) { 
  
  cerr << endl 
       << TString::Format("ERROR in %s: %s", location.Data(), message.Data()) 
       << endl; 
  return; 
}
////////////////////////////////////////////////////////////////////////////////////
void THRS::VDC::Parse_offsets( const TString path_DB ) { 
  
  const TString here = "THRS::VDC::Parse_offsets()"; 
    
  cout << TString::Format("%s => parsing data from \"%s\"...",
			  here.Data(),
			  path_DB.Data()) 
       << flush; 
  
  fstream db; db.open( path_DB.Data(), ios::in );   
  
  //failed to open file! 
  if (!db) { 
    THRS::ReportError(here,"File could not be opened!"); 
    return; 
  }
    
  TString str; 
  
  bool arm; 
  
  while ( !db.eof() ) { 
    
    //check which arm we're looking at
    db >> str; 
    
    if (str!="R" && str!="L") { 
      THRS::ReportError(here,TString::Format("Bad arm-name given! \"%s\"", 
					     str.Data()) ); 
      return; 
    }
    
    if (str=="R") { arm=THRS::Arm_Right; } else { arm=THRS::Arm_Left; }
    
    //check which plane we're looking at
    db >> str; 
    
    int plane = atoi(str); 
    
    if (plane>=VDC::fN_PLANES || plane<0) { 
      THRS::ReportError(here,"Bad plane number given!"); 
      return; 
    }
    
    //read offsets
    int wire=0; db >> str; 
    while (str != "eol") { 
      
      if (arm==THRS::Arm_Right) { 
	VDC::offset_RHRS[plane][wire] = stod((string)str); 
      } else                    { 
	VDC::offset_LHRS[plane][wire] = stod((string)str); 
      }
      
      wire++; 
      db >> str; 
    }
    
    if (wire > VDC::fN_WIRES || wire < VDC::fN_WIRES) { 
      THRS::ReportError(here,
			TString::Format("bad num of wires! p-%i, n.wires=%i",
					plane, wire)); 
      
      if (arm==THRS::Arm_Right) { VDC::status_RHRS[plane] = VDC::Error; }
      else                      { VDC::status_LHRS[plane] = VDC::Error; }
      
    } else { 
      
      //if we've gotten here, then we've parsed the offsets successfully
      if (arm==THRS::Arm_Right) { VDC::status_RHRS[plane] = VDC::Ok; }
      else                      { VDC::status_LHRS[plane] = VDC::Ok; } 
    }
    
    if (plane==VDC::fN_PLANES-1) break; 
  }
  
  /*for (int p=0; p<VDC::fN_PLANES; p++) { 
    
    copy( begin(R_abs[p]), end(R_abs[p]), begin(VDC::offset_RHRS[p]) ); 
    copy( begin(L_abs[p]), end(L_abs[p]), begin(VDC::offset_LHRS[p]) ); 
    }*/ 
  
  
  
  cout << "done" << endl; 
  return; 
}
////////////////////////////////////////////////////////////////////////////////////
bool THRS::VDC::Print_status() const { 
  
  //print status for offset-parsing for all planes. 
  const TString here = "THRS::VDC::Print_status()"; 
  
  cout << here << " => Parsing status for all planes:" << endl; 
  
  bool allGood=true; 
  
  cout << "HRS - Right~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl; 
  for (int p=0; p<VDC::fN_PLANES; p++) { 
    
    cout << TString::Format("plane %i, status = ",p); 
    
    switch (VDC::status_RHRS[p]) { 
    case VDC::Ok      : cout << "Ok" << endl;              break; 
    case VDC::NotInit : cout << "Not initialized" << endl; allGood=false; break;  
    case VDC::Error   : cout << "Error!" << endl;          allGood=false; break; 
    default           : cout << "Unknown status!" << endl; allGood=false; break; 
    }
  } 
  cout << "HRS - Left~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl; 
  for (int p=0; p<VDC::fN_PLANES; p++) { 
    
    cout << TString::Format("plane %i, status = ",p); 
    
    switch (VDC::status_LHRS[p]) { 
    case VDC::Ok      : cout << "Ok" << endl;              break; 
    case VDC::NotInit : cout << "Not initialized" << endl; allGood=false; break;  
    case VDC::Error   : cout << "Error!" << endl;          allGood=false; break; 
    default           : cout << "Unknown status!" << endl; allGood=false; break; 
    }
  } 
    
  cout << "Overall initialization status: " << (allGood?"good.":"bad!") << endl; 
  
  return allGood; 
}
////////////////////////////////////////////////////////////////////////////////////
double THRS::VDC::WirePos( const bool arm, 
			   const int  plane, 
			   const int  wireNum ) { 
  
  const TString here = "THRS::VDC::WirePos()"; 
  
  //check if plane is valid
  if (plane >= THRS::VDC::fN_PLANES || plane < 0) {
    
    string msg 
      = (string)TString::Format("second arg. out-of-range: planes=[0,%i], given %i",
				THRS::VDC::fN_PLANES, 
				plane); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  
  //check if wire is valid
  if (wireNum >= THRS::VDC::fN_WIRES || wireNum < 0) {
    
    string msg 
      = (string)TString::Format("third arg. out-of-range: wires=[0,%i], given %i",
				THRS::VDC::fN_WIRES, 
				wireNum); 
  
    THRS::ReportError( here, msg ); return -1e30; 
  }
  
  //the position of the closest wire (with a lower u- or v-value) 
  double x_offset = (arm==THRS::Arm_Right) 
    ? VDC_wire0_R[plane]
    : VDC_wire0_L[plane]; 
     
  return x_offset  -  THRS::VDC::wireSpacing*((double)wireNum);    
}
////////////////////////////////////////////////////////////////////////////////  
int    THRS::VDC::WireNum( const bool   arm, 
			   const int    plane, 
			   const double x ) { 
  
  const TString here = "THRS::VDC::WireNum()"; 
  
  //check if plane is valid
  if (plane >= THRS::VDC::fN_PLANES || plane < 0) {
    
    string msg 
      = (string)TString::Format("second arg. out-of-range: planes=[0,%i], given %i",
				THRS::VDC::fN_PLANES, 
				plane); 
    
    THRS::ReportError( here, msg ); return -999; 
  }
  
  double x_offset = (arm==THRS::Arm_Right) 
    ? VDC_wire0_R[plane]
    : VDC_wire0_L[plane]; 
  
  return (int)TMath::Nint( (x_offset - x)/THRS::VDC::wireSpacing );  
}
double THRS::VDC::RealTime( const bool arm, 
			    const int plane, 
			    const int wireNum, 
			    const double rawTime ) {
  
  const TString here = "THRS::VDC::RealTime()"; 
       
  //check if plane is valid
  if (plane >= THRS::VDC::fN_PLANES || plane < 0) {
    
    string msg 
      = (string)TString::Format("second arg. out-of-range: planes=[0,%i], given %i",
				THRS::VDC::fN_PLANES, 
				plane); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  
  //check if it's been initalized
  if ( (arm==THRS::Arm_Right && VDC::status_RHRS[plane] != VDC::Ok) ||
       (arm==THRS::Arm_Left  && VDC::status_LHRS[plane] != VDC::Ok) ) { 
    
    THRS::ReportError( here, "VDC offsets not correctly initialized!" ); 
    return -1e30; 
  }
  
  if (wireNum >= THRS::VDC::fN_WIRES || wireNum < 0) {
    
    string msg 
      = (string)TString::Format("third arg. out-of-range: wires=[0,%i], given %i",
				THRS::VDC::fN_WIRES, 
				wireNum); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  //vdc wire offsets
  
  Double_t offset = (arm==THRS::Arm_Right) 
    ? VDC::offset_RHRS[plane][wireNum]
    : VDC::offset_LHRS[plane][wireNum]; 
    
  return (THRS::VDC::TDC_resolution * rawTime)  +  offset; 
}
double THRS::VDC::RawTime( const bool arm, 
			   const int plane, 
			   const int wireNum, 
			   const double realTime ) {
  
  const TString here = "THRS::VDC::RealTime()"; 
  
  //check if plane is valid
  if (plane >= THRS::VDC::fN_PLANES || plane < 0) {
    
    string msg 
      = (string)TString::Format("second arg. out-of-range: planes=[0,%i], given %i",
				THRS::VDC::fN_PLANES, 
				plane); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  //check if it's been initalized
  if ( (arm==THRS::Arm_Right && VDC::status_RHRS[plane] != VDC::Ok) ||
       (arm==THRS::Arm_Left  && VDC::status_LHRS[plane] != VDC::Ok) ) { 
    
    THRS::ReportError( here, "VDC offsets not correctly initialized!" ); 
    return -1e30; 
  }
  
  
  if (wireNum >= THRS::VDC::fN_WIRES || wireNum < 0) {
    
    string msg 
      = (string)TString::Format("third arg. out-of-range: wires=[0,%i], given %i",
				THRS::VDC::fN_WIRES, 
				wireNum); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  //vdc wire offsets
  
  Double_t offset = (arm==THRS::Arm_Right) 
    ? VDC::offset_RHRS[plane][wireNum]
    : VDC::offset_LHRS[plane][wireNum]; 
    
  return (realTime  - offset)/THRS::VDC::TDC_resolution; 
}
////////////////////////////////////////////////////////////////////////////////////
double THRS::VDC::w( const bool arm, const int plane ) { 
  
  const string here = "THRS::VDC::w()"; 
  
  //check if plane is valid
  if (plane >= THRS::VDC::fN_PLANES || plane < 0) {
    
    string msg 
      = (string)TString::Format("second arg. out-of-range: planes=[0,%i], given %i",
				THRS::VDC::fN_PLANES, 
				plane); 
    
    THRS::ReportError( here, msg ); return -1e30; 
  }
  
  return (arm==THRS::Arm_Right) 
    ? VDC_w_R[plane] 
    : VDC_w_L[plane]; 
}
////////////////////////////////////////////////////////////////////////////////////
TS2Hit::TS2Hit( bool arm, int paddle, double T_pmtL, double T_pmtR ) {
  
  f_isRightArm =arm; 
  fPaddle      =paddle; 
  
  fRawTime_pmtL =T_pmtL; 
  fRawTime_pmtR =T_pmtR; 
  
  fTime = Compute_RealTime(); 
  
  fIsCoinc = (fTime > -1e29); 

  //get the location of the paddle
  fZ = f_isRightArm ? 3.3098 : 3.1790 ; 
  
  fX = ((double)fPaddle)*fPaddleWidth_X  + (f_isRightArm ? -1.21413 : -1.16913); 
  
  fY = 0; 
}
double TS2Hit::Compute_RealTime() {
  
  //check to make sure that the PMTs registered non-null times
  if (TMath::Abs(fRawTime_pmtL) > 1e10 || 
      TMath::Abs(fRawTime_pmtR) > 1e10) return -1e30; 
  
  if (f_isRightArm) { //RHRS 
    
    fRealTime_pmtR = ( Right_R[fPaddle] - fRawTime_pmtR )*fTDC_resolution;
    fRealTime_pmtL = ( Right_L[fPaddle] - fRawTime_pmtL )*fTDC_resolution; 
  
  } else      { 
    
    fRealTime_pmtR = ( Left_R[fPaddle]  - fRawTime_pmtR )*fTDC_resolution; 
    fRealTime_pmtL = ( Left_L[fPaddle]  - fRawTime_pmtL )*fTDC_resolution; 
  }
    
  //check to make sure the raw times agree 
  
  if (TMath::Abs(fRealTime_pmtR-fRealTime_pmtL) > 7.5e-9) return -1e30; 
  
  return 0.5*(fRealTime_pmtR + fRealTime_pmtL); 
}
void TS2Hit::Make_twinHit( TS2Hit *neighbor ) { 
  
  fTime = 0.5*(fTime + neighbor->Time()); 
  
  fX += 0.5*fPaddleWidth_X; 
  
  f_isTwinHit = true; 
} 
/////////////////////////////////////////////////////////////////////////////////
TvdcHit::TvdcHit( int plane, 
		  double wire, 
		  double rawTime, 
		  TEventHandler *event ) { 
  
  fEvent = event; 
  
  f_isRightArm = fEvent->ActiveArm(); 
  
  fPlane    = plane; 
  fRawTime  = rawTime; 
  fWireNum  = (int)wire; 
  fWirePos  = THRS::VDC::WirePos( f_isRightArm, 
				  fPlane,
				  fWireNum );
  
  fRealTime 
    = THRS::VDC::RealTime( f_isRightArm, 
			   fPlane, 
			   fWireNum, 
			   fRawTime )  -  fEvent->GetS2Hit()->Time();
    
  fW = f_isRightArm ? VDC_w_R[fPlane] : VDC_w_L[fPlane]; 
}
void   TvdcHit::SetRawTime(const double rawTime)  { 
  
  fRawTime  = rawTime; 
  fRealTime = GetRealTime( fRawTime ) - fEvent->GetS2Hit()->Time(); 
} 
double TvdcHit::GetWirePos( int wire )      const {
  
  if (f_isRightArm) {
    
    Double_t v0[4] = {0.77852, 0.77852, 1.02793, 1.02793}; 
    return v0[fPlane] - fWireSpacing*((double)wire);
    
  } else { 
    
    Double_t v0[4] = {0.77852, 0.77852, 1.02718, 1.02718};
    return v0[fPlane] - fWireSpacing*((double)wire);
  }
}
double TvdcHit::GetRealTime(double rawTime) const {
  
  //vdc wire offsets
  
  Double_t offset = (f_isRightArm) 
    ? R_abs[fPlane][fWireNum]-1.04e-9 : L_abs[fPlane][fWireNum]+3.20e-9; 
    
  return (-0.5e-9)*rawTime + offset; 
}
double TvdcHit::RawTime( const bool is_RightArm, 
			 const int plane, 
			 const int wireNum, 
			 const double realTime ) { 
  
  double offset = is_RightArm ? R_abs[plane][wireNum] : L_abs[plane][wireNum]; 
  
  return (realTime - offset)/(-0.5e-9); 
}
int    TvdcHit::WireNum( const bool   is_RightArm, 
			 const int    plane, 
			 const double wirePos ) { 
  
  //the position of the closest wire (with a lower u- or v-value) 
  double x_offset; 
  if (is_RightArm) { x_offset = plane<2 ? 0.77852 : 1.02793; }
  else             { x_offset = plane<2 ? 0.77852 : 1.02718; }
  
  return (int)TMath::Nint( (x_offset - wirePos)/TvdcHit::WireSpacing() );  
}
double TvdcHit::WirePos( const bool is_RightArm, 
			 const int  plane, 
			 const int  wireNum ) { 
  
  //the position of the closest wire (with a lower u- or v-value) 
  double x_offset; 
  if (is_RightArm) { x_offset = plane<2 ? 0.77852 : 1.02793; }
  else             { x_offset = plane<2 ? 0.77852 : 1.02718; }
      
  return x_offset  -  TvdcHit::WireSpacing()*((double)wireNum);    
}
////////////////////////////////////////////////////////////////////////////////  
THitGroup::THitGroup(int plane) { 
    
  fPlane=plane; 
}  
THitGroup::~THitGroup() {  
  //delete all constituent hits
  for (unsigned int h=0; h<fHits.size(); h++) fHits.at(h)->~TvdcHit(); 
}
void THitGroup::AddHit( double wire, double rawTime ) { 
  
  fHits.push_back( new TvdcHit(fPlane,wire,rawTime) ); 
}
double THitGroup::WirePos( unsigned int h ) const { 
  
  if (h>=Nhits()) return kNull_double; 
  
  return fHits.at(h)->wPos();
}
int    THitGroup::WireNum( unsigned int h ) const { 
  
  if (h>=Nhits()) return kNull_int; 
  
  return fHits.at(h)->wNum(); 
}
double THitGroup::Time( unsigned int h )    const { 
  
  if (h>=Nhits()) return kNull_double; 
  
  return fHits.at(h)->Time(); 
}
int    THitGroup::FirstWire() const { return WireNum(0); }
double THitGroup::LoEdge()    const { return WirePos(Nhits()-1); }
double THitGroup::HiEdge()    const { return WirePos(0); }
////////////////////////////////////////////////////////////////////////////////  
THitCluster::THitCluster( THitGroup *group, 
			  const double intercept, 
			  const double eta ) { 
  fGroup     =group; 
  fIntercept =intercept; 
  fEta_score =eta; 
}
///////////////////////////////////////////////////////////////////////////////
TChamberPair::TChamberPair( bool is_loChamber,
			    double u,
			    double v,
			    THitGroup *Group_U,
			    THitGroup *Group_V, 
			    int unique_id ) {
  
  f_isLoChamber = is_loChamber; 
  fu = u; 
  fv = v; 
  fGroup_U = Group_U;
  fGroup_V = Group_V; 
  
  fUnique_ID = unique_id; 
}
TChamberPair::TChamberPair( bool is_loChamber, 
			    THitCluster *clust_u,
			    THitCluster *clust_v, 
			    int unique_id ) { 

  f_isLoChamber = is_loChamber; 
  
  fu = clust_u->Intercept(); 
  fv = clust_v->Intercept(); 
  
  fGroup_U = clust_v->GetGroup(); 
  fGroup_V = clust_u->GetGroup(); 
  
  fUnique_ID = unique_id; 
}
void TChamberPair::Remove_track( TObject* track ) { 
  
  //cout << "TChamberPair:: removing track.."<< endl; 
  
  auto trk_it = find( begin(fTracks), end(fTracks), track ); 
  
  if (trk_it==fTracks.end()) {
    cout << "WARNING: track not found in TChamberPair" << endl; 
    return; 
  }
  
  fTracks.erase( trk_it ); 
}

  
double TChamberPair::ClosestWirePos_Lo( double x ) const { 
  
  //the position of the closest wire (with a lower u- or v-value) 
  
  double vOffR[4] = {0.77852, 0.77852, 1.02793, 1.02793}; 
  double vOffL[4] = {0.77852, 0.77852, 1.02718, 1.02718};
  
  int fPlane = f_isLoChamber ? 0 : 2; 
  
  double planeOffset = fGroup_U->IsRightArm() ? vOffR[fPlane] : vOffL[fPlane]; 
    
  double wireNum = (double)ceil( (planeOffset - x)/TvdcHit::WireSpacing() );  
    
  return planeOffset  -  TvdcHit::WireSpacing()*wireNum;    
}
double TChamberPair::ClosestWirePos( const double x ) const { 
  
  double vOffR[4] = {0.77852, 0.77852, 1.02793, 1.02793}; 
  double vOffL[4] = {0.77852, 0.77852, 1.02718, 1.02718};
  
  int fPlane = f_isLoChamber ? 0 : 2; 
  
  double planeOffset = fGroup_U->IsRightArm() ? vOffR[fPlane] : vOffL[fPlane]; 
    
  double wireNum = TMath::Nint( (planeOffset - x)/TvdcHit::WireSpacing() );  
    
  return planeOffset  -  TvdcHit::WireSpacing()*wireNum;    
}
////////////////////////////////////////////////////////////////////////////////  
double fDrift_param_L_BC_Lo[5][5] 
= { {3.562e-3, 3.517e-3, 3.587e-3, 3.403e-3, 3.342e-3}, 
    {4.287e-8, 4.200e-8, 4.087e-8, 3.834e-8, 3.554e-8}, 
    {2.114e-5, 2.095e-5, 2.077e-5, 2.036e-5, 2.033e-5}, 
    {4.735e-3, 4.652e-3, 4.547e-3, 4.271e-3, 3.654e-3}, 
    {8.510e-9, 8.510e-9, 8.510e-9, 8.510e-9, 8.510e-9} }; 

/*= { {2.718e-3, 2.658e-3, 2.530e-3, 2.299e-3, 2.349e-3}, 
    {3.106e-8, 2.968e-8, 2.844e-8, 2.879e-8, 2.950e-8},
    {2.201e-5, 2.152e-5, 2.098e-5, 2.038e-5, 2.046e-5},
    {5.042e-3, 4.709e-3, 3.965e-3, 4.430e-3, 4.501e-3}, 
    {6.603e-9, 4.276e-9, 1.888e-9, 1.872e-9, 3.195e-9} }; */ 

double fDrift_param_L_BC_Hi[5][5] 
= { {3.173e-3, 3.280e-3, 3.347e-3, 3.500e-3, 3.621e-3}, 
    {4.218e-8, 4.205e-8, 4.156e-8, 4.164e-8, 4.128e-8},
    {2.105e-5, 2.101e-5, 2.087e-5, 2.091e-5, 2.083e-5}, 
    {4.514e-3, 4.546e-3, 4.543e-3, 4.584e-3, 4.605e-3}, 
    {1.325e-8, 1.550e-8, 1.800e-8, 1.950e-8, 2.150e-8} }; 

//    {5.750e-9, 8.000e-9, 1.050e-8, 1.200e-8, 1.400e-8} }; */ 


double fParams_R[5][5] 
= { {3.774e-3, 3.774e-3, 3.774e-3, 3.774e-3, 3.774e-3}, 
    {3.618e-8, 3.618e-8, 3.618e-8, 3.618e-8, 3.618e-8},
    {2.024e-5, 2.024e-5, 2.024e-5, 2.024e-5, 2.024e-5},
    {3.864e-3, 3.864e-3, 3.864e-3, 3.864e-3, 3.864e-3},
    {1.431e-8, 1.431e-8, 1.431e-8, 1.431e-8, 1.431e-8} }; 

//first run which is 'fixed' 
const int FIRST_FIXED_RUN = 4619; 

const int N_PARAMS =5;
const int Npts_SLOPE =5; 
  
double slopeNodes_R[5] = { 1.144, 1.363, 1.473, 1.582, 1.868 };
double slopeNodes_L[5] = { 1.155, 1.336, 1.419, 1.509, 1.824 }; 
  
double f_BEAM_CURRENT[2] = {17., 53.};

double fDrift_param_R[5][5];

const int blur_nSamples = 25; 
const double blur_sigma =0.20e-3; 

const double beamCurrent_DEFAULT_VALUE = 30.; 

const double zQuantSpread[25] = { -2.053749, 
				  -1.554774, 
				  -1.281552, 
				  -1.080319, 
				  -0.915365, 
				  -0.772193, 
				  -0.643345, 
				  -0.524401, 
				  -0.412463, 
				  -0.305481, 
				  -0.201893, 
				  -0.100434, 
				   0.000000, 
 				   0.100434, 
 				   0.201893, 
				   0.305481, 
				   0.412463, 
				   0.524401, 
				   0.643345, 
				   0.772193, 
				   0.915365, 
				   1.080319, 
				   1.281552, 
				   1.554774, 
				   2.053749  }; 


double z_spread[25]; 
double dP_spread; 


using namespace std;

TEventHandler::TEventHandler( bool arm, 
			      double beamCurrent,
			      int runNumber, 
			      TS2Hit *fHit_R, 
			      TS2Hit *fHit_L ) { 
  f_activeArm  =arm; 
  
  fRunNumber = runNumber; 
  
  fBeamCurrent = beamCurrent; 
  
  
  if (fBeamCurrent < -1e3) { 
    f_isNullBeamCurrent=true; 
    fBeamCurrent = beamCurrent_DEFAULT_VALUE; 
  }
  
  fS2Hit_Right = fHit_R; 
  fS2Hit_Left  = fHit_L;  

  //develop drift-parameters for left arm
  for (int s=0; s<Npts_SLOPE; s++) { 
    for (int p=0; p<N_PARAMS; p++) { 
      
      if (fRunNumber < FIRST_FIXED_RUN) {
	double f_PARAM_INTERPOLATE[2] = { fDrift_param_L_BC_Lo[p][s], 
					  fDrift_param_L_BC_Hi[p][s] }; 
	
	fParams_L[p][s] = Interpolate( beamCurrent, 
				       f_BEAM_CURRENT, 
				       f_PARAM_INTERPOLATE, 2 ); 
	
      } else { fParams_L[p][s]=fParams_R[p][s]; }
    }
  }
  //this is to blur the model, to get rid of 'sharp points
  dP_spread = 1./((double)blur_nSamples);  double cum_P(dP_spread*0.50); 
  
  for (int i=0; i<blur_nSamples; i++) { 
    
    z_spread[i] = blur_sigma*zQuantSpread[i]; 
    cum_P += dP_spread;
  }
  
} 
double f_SIGMA_INTERPOLATE[2] = { 5e-9, 5e-9 }; 
double f_SIGMA_FIXED = 5e-9; 

double TEventHandler::Get_tauSigma() const { 
  
  if (fRunNumber < FIRST_FIXED_RUN && ActiveArm()==false ) { 
    
    return Interpolate( fBeamCurrent, f_BEAM_CURRENT, f_SIGMA_INTERPOLATE, 2 ); 
  } 
  return f_SIGMA_FIXED; 
}
double TEventHandler::Drift_X( double tau, double slope, int derivative ) const { 
  
  double par[N_PARAMS];
  
  if (ActiveArm()==true) {
    
    for (int p=0; p<N_PARAMS; p++) 
      par[p] = Interpolate( slope, slopeNodes_R, fParams_R[p], Npts_SLOPE ); 
    
  } else                 { 
    
    for (int p=0; p<N_PARAMS; p++) 
      par[p] = Interpolate( slope, slopeNodes_L, fParams_L[p], Npts_SLOPE ); 
  }
  
  double x1(par[0]), y1(par[1]), m(par[2]), b(par[3]), y0(par[4]); 
  
  
  if (tau<y0) return 0; 
  
  if (tau<y0+y1) 
    return 0.5*( -b + sqrt( b*b + 4.*(tau-y0)*(x1*x1 + b*x1)/y1 )  ); 
  
  return ( tau - (y0+y1) )/m + x1; 
}
double TEventHandler::Drift_T_raw( const double x, 
				   const double *par, 
				   const int derivative ) const {
  
  double x1(par[0]), y1(par[1]), m(par[2]), b(par[3]), y0(par[4]); 
  
  double absX = TMath::Abs(x); 
  
  if (derivative==0) 
    return absX < x1  
      ? y1*(x*x + b*absX)/(x1*x1 + b*x1)  +  y0 
      : m*(absX - x1)  +  y1  +  y0; 
  
  if (derivative==1) 
    return absX < x1 
      ? y1*(2.*x + TMath::Sign(b,x) )/(x1*x1 + b*x1) 
      : TMath::Sign(m,x); 
  
  //derivative==2
  return absX < x1  ?  y1*( 2. )/(x1*x1 + b*x1)  :  0.; 
}
double TEventHandler::Drift_T( double x, double slope, int derivative ) const { 
  
  double par[N_PARAMS];
  
  if (ActiveArm()==true) {
    
    for (int p=0; p<N_PARAMS; p++) 
      par[p] = Interpolate( slope, slopeNodes_R, fParams_R[p], Npts_SLOPE ); 
    
  } else                 {    
    
    for (int p=0; p<N_PARAMS; p++) 
      par[p] = Interpolate( slope, slopeNodes_L, fParams_L[p], Npts_SLOPE ); 
  }

  //blur higher derivatives
  const double h=blur_sigma*0.6;

  if (TMath::Abs(x) < par[0]+blur_sigma*5.) {
        
    double Tau(0.); 
        
    if (derivative >0) {

      for (int i=0; i<blur_nSamples; i++) { 
      	Tau 
	  += Drift_T_raw( x+h+z_spread[i], par, derivative-1 )
	  -  Drift_T_raw( x-h+z_spread[i], par, derivative-1 ); 
      }
      return Tau*dP_spread/(2.*h); 
      
    } else             {
      
      for (int i=0; i<blur_nSamples; i++) 
	Tau 
	  += Drift_T_raw( x+z_spread[i], par ); 
      
      return Tau*dP_spread; 
    }
  } else  { 
    
    return Drift_T_raw( x, par, derivative );
  }    
  
}
double TEventHandler::Interpolate( const double x, 
				   const double *X, 
				   const double *Y, 
				   const int nPts   ) const {

  //interpolate between the points in X & Y. 'nPts' should be the n. of points
  //                                          in BOTH the X & Y arrays.
  // if 'x' is out of the bounds of X, then it just returns the value of the 
  // closest extreme value of Y. 
  int zone(0); 
  
  //find which 'zone' we're in
  while ( zone < nPts ) { 
    
    if (x < X[zone]) break; zone++; 
  }
  
  //we're in zone=0, which means we're out-of-bounds, to the left. 
  if (zone==0)    return Y[0];
  
  //we're in zone=nPts, which means we're out-of-bounds, to the right. 
  if (zone==nPts) return Y[nPts-1]; 
  
  //if were in a valid 'zone', then interpolate
  return Y[zone-1] + (Y[zone]-Y[zone-1])*( (x - X[zone-1])/(X[zone]-X[zone-1]) ); 
 
}
//////////////////////////////////////////////////////////////////////////////////
void TvdcTrack::UpdateTrackInfo() { 
  
  //check to see if this track has VDC data. 
  if ( !fPair_Lo || !fPair_Hi ) { f_hasVDCdata=false; } else { f_hasVDCdata=true; }
    
  //tell the point-pairs about their actual slope-values
  double wSep = fW[2]-fW[0]; //the U2-U1 & V2-V1 separations are the same
  
  if (f_hasVDCdata) { 
    //if we DO have vdc data, we want to keep track of the 'pair' intercepts as 
    // best we can.
    fIntercept[0] = fPair_Lo->v(); 
    fIntercept[1] = fPair_Lo->u(); 
    fIntercept[2] = fPair_Hi->v(); 
    fIntercept[3] = fPair_Hi->u(); 
  } 
  
  double 
    uLo(fIntercept[1]),
    vLo(fIntercept[0]),
    uHi(fIntercept[3]),
    vHi(fIntercept[2]); 
  
  fSlope_u = wSep/(uHi-uLo); 
  fSlope_v = wSep/(vHi-vLo);  
  
  if (f_hasVDCdata) { 
    fPair_Hi->SetSlope_uv( fSlope_u, fSlope_v ); 
    fPair_Lo->SetSlope_uv( fSlope_u, fSlope_v ); 
  }
  
  f_S2Int_xyz = ComputeIntercept_z( fEvent->GetS2Hit()->Z() ); 
  
  //we need to find the 'speed' of the track in the u & v directions. 
  //the 'true' speed of the track thru the VDC is effectivley c, but 
  //since the track isn't travelling parallel to the 'u' or 'v' axes, we 
  //need to adjust accordingly. this will be used to compute Time-of-Flight (ToF)
  //for the track at any given wire crossing. 
  TVector3 S2Int_uvw =  TvdcTrack::Rotate_xyz_to_uvw( f_S2Int_xyz ); 
  
  fS2_u = S2Int_uvw[0]; 
  fS2_v = S2Int_uvw[1]; 
    
  TVector3 S_uvw  = TVector3( 1./fSlope_u, 1./fSlope_v, 1. ).Unit(); 
  
  //these are the 'speeds' of the particle in the 'U' or 'V' direction, assuming 
  // the overall speed of the particle is 'c'. 
  fC_u = fC * S_uvw[0]; 
  fC_v = fC * S_uvw[1]; 
  
  //compute focal plane intercept
  f_FPInt_xyz = ComputeIntercept_z(0.); 
    
  TVector3 S_xyz = TvdcTrack::Rotate_uvw_to_xyz( S_uvw ); 
  
  fTheta = TMath::ATan( S_xyz.X()/S_xyz.Z() ); 
  fPhi   = TMath::ATan( S_xyz.Y()/S_xyz.Z() ); 
}
TvdcTrack::TvdcTrack( TEventHandler *event, 
		      TChamberPair *pLo, 
		      TChamberPair *pHi ) { 
  
  fEvent = event; 
  
  f_isRightArm = fEvent->ActiveArm(); 
  
  if (f_isRightArm) { //
    
    copy( begin(VDC_w_R), end(VDC_w_R), begin(fW) );  
  
  } else                   {
    
    copy( begin(VDC_w_L), end(VDC_w_L), begin(fW) );   
  }
  
  //if we're making a new monte-carlo track, skip this step. 
  if ( !pLo || !pHi ) { f_hasVDCdata=false; } else { f_hasVDCdata=true; }
  
  if (f_hasVDCdata) { 
    
    fPair_Lo = pLo;   fPair_Lo->Add_track( this );
    fPair_Hi = pHi;   fPair_Hi->Add_track( this ); 
    
    fGroup[0] = (THitGroup*)fPair_Lo->GetGroup_U(); 
    fGroup[1] = (THitGroup*)fPair_Lo->GetGroup_V();
    
    fGroup[2] = (THitGroup*)fPair_Hi->GetGroup_U(); 
    fGroup[3] = (THitGroup*)fPair_Hi->GetGroup_V(); 
  
    UpdateTrackInfo(); 
  }
  
}

const double 
R_xu( 0.500000),  R_xv(0.500000), R_xw(-0.707107), 
  R_yu(-0.707107),  R_yv(0.707107), R_yw( 0.0),
  R_zu( 0.500000),  R_zv(0.500000), R_zw(0.707107); 

void TvdcTrack::Set_Errors( double errors[5] ) { 
  
  for (int p=0; p<4; p++) fIntercept_ERR[p] =errors[p]; 

  fT0_ERR = errors[4]; 
  
  /*/compute Theta-error
    TVector3 S_xyz 
    = TvdcTrack::Rotate_uvw_to_xyz( TVector3(1./fSlope_u, 1./fSlope_v, 1.) ); 
  
  double sx(S_xyz[0]), sy(S_xyz[1]), sz(S_xyz[2]); 
  
  double d_Theta = 0.; 
  
  double d_arctan = 1./( 1. + (sx*sx)/(sz*sz) ); 
  
  double Dw = f_isRightArm 
    ? VDC_w_R[2]-VDC_w_R[0] 
    : VDC_w_L[2]-VDC_w_L[0]; //separation between vdc planes
  
  //U1 - plane
  d_Theta
    +=  TMath::Power( fIntercept_ERR[0]
		      * d_arctan * (sz*R_xv/Dw - sx*R_zv/Dw)/(sz*sz), 2 ); 
  
  //U2 - plane
  d_Theta 
    +=  TMath::Power( fIntercept_ERR[2]
		      * d_arctan * (sz*R_xv/Dw - sx*R_zv/Dw)/(sz*sz), 2 ); 
  
  //V1 - plane
  d_Theta 
    +=  TMath::Power( fIntercept_ERR[1]
		      * d_arctan * (sz*R_xu/Dw - sx*R_zu/Dw)/(sz*sz), 2 ); 
  
  //V2 - plane
  d_Theta 
    +=  TMath::Power( fIntercept_ERR[3]
		      * d_arctan * (sz*R_xu/Dw - sx*R_zu/Dw)/(sz*sz), 2 ); 
  
  
		      fTheta_ERR = TMath::Sqrt( d_Theta ); //*/ 
    
}
void   TvdcTrack::Set_Eta(double eta[4]) { 

  for (int p=0; p<4; p++) Set_Eta(p, eta[p]); 
} 
double TvdcTrack::Get_Eta() const { 
  
  double eta(0.); 
  for (int p=0; p<4; p++) eta += Get_Eta(p); 
  return eta; 
}
int    TvdcTrack::Get_nGoodPoints() const { 
  
  int nPts(0); 
  for (int p=0; p<4; p++) nPts += Get_nGoodPoints(p); 
  return nPts; 
} 
double TvdcTrack::Get_RMS() const { 
  
  double RMS(0.); 
  for (int p=0; p<4; p++) RMS += 0.25*TMath::Power( Get_RMS(p), 2. ); 
  return TMath::Sqrt( RMS ); 
} 
double TvdcTrack::Error_allIntercept() const { 
  
  double RMS(0.); 
  for (int p=0; p<4; p++) RMS += 0.25*TMath::Power( Error_intercept(p), 2. ); 
  return TMath::Sqrt( RMS ); 
}
void TvdcTrack::Set_S2int_angles( double s2x, 
				  double s2y, 
				  double theta, 
				  double phi )   { 
  
  //this is an alternate way to initialize the track without VDC data 
  // (used for monte-carlo processing, in which a track's position is created 
  //  before the corresponding VDC hits are created). 
  
  if ( !fPair_Lo || !fPair_Hi ) { f_hasVDCdata=false; } else { f_hasVDCdata=true; }
    
  f_S2Int_xyz = TVector3( s2x, s2y, fEvent->GetS2Hit()->Z() ); 
  
  TVector3 S_xyz( TMath::Tan(theta), TMath::Tan(phi), 1. ); 
  
  TVector3 S_uvw = TvdcTrack::Rotate_xyz_to_uvw( S_xyz ).Unit(); 
  
  fSlope_u = S_uvw.Z()/S_uvw.X(); 
  fSlope_v = S_uvw.Z()/S_uvw.Y(); 
    
  f_FPInt_xyz = TVector3( f_S2Int_xyz - S_xyz*f_S2Int_xyz.Z() ); 
    
  auto S2u = TvdcTrack::Rotate_xyz_to_uvw( f_S2Int_xyz ); 
  auto FPu = TvdcTrack::Rotate_xyz_to_uvw( f_FPInt_xyz ); 
    
  fIntercept[0] = ( fW[0]-FPu.Z() )/fSlope_v  +  FPu.Y(); 
  
  fIntercept[1] = ( fW[1]-FPu.Z() )/fSlope_u  +  FPu.X();
  
  fIntercept[2] = ( fW[2]-FPu.Z() )/fSlope_v  +  FPu.Y(); 
  
  fIntercept[3] = ( fW[3]-FPu.Z() )/fSlope_u  +  FPu.X();

  TvdcTrack::Compute_Theta_Phi( f_isRightArm, 
				fIntercept, 
				fTheta, fPhi ); 
  
  //fTheta = TMath::ATan( S_xyz.X()/S_xyz.Z() ); 
  //fPhi   = TMath::ATan( S_xyz.Y()/S_xyz.Z() ); 
  
  fS2_u = S2u[0]; 
  fS2_v = S2u[1]; 
    
  fC_u = fC * S_uvw[0]; 
  fC_v = fC * S_uvw[1]; 
  
  UpdateTrackInfo(); 
}
void TvdcTrack::SetPair_Hi( TChamberPair *pHi ) { 
  
  //if the old pair exists, tell it that we're breaking up with it
  // (it's not you, it's me..) 
  if (fPair_Hi) fPair_Hi->Remove_track( this );
  
  fPair_Hi = pHi; fPair_Hi->Add_track( this ); 
  
  fGroup[2] = fPair_Hi->GetGroup_U(); 
  fGroup[3] = fPair_Hi->GetGroup_V(); 
  UpdateTrackInfo(); 
}
void TvdcTrack::SetPair_Lo( TChamberPair *pLo ) { 
  
  //if the old pair exists, tell it that we're breaking up with it
  // (it's not you, it's me..) 
  if (fPair_Lo) fPair_Lo->Remove_track( this );
  
  fPair_Lo = pLo; fPair_Lo->Add_track( this ); 
  
  fGroup[0] = fPair_Lo->GetGroup_U(); 
  fGroup[1] = fPair_Lo->GetGroup_V();
  UpdateTrackInfo(); 
} 
void TvdcTrack::Set_uv_Hi( const double u, 
			   const double v ) { 
  if(fPair_Hi) { fPair_Hi->Set_uv( u,v ); } 
  else         { fIntercept[2]=v; fIntercept[3]=u; }
  UpdateTrackInfo(); 
}
void TvdcTrack::Set_uv_Lo( const double u, 
			   const double v ) { 
  if(fPair_Lo) { fPair_Lo->Set_uv( u,v ); } 
  else         { fIntercept[0]=v; fIntercept[1]=u; }
  UpdateTrackInfo(); 
}
double TvdcTrack::Slope_u() { return fSlope_u; }
double TvdcTrack::Slope_v() { return fSlope_v; }
  
void   TvdcTrack::Set_intercept(int plane, double x) { 
  
  if (plane==0) { if (fPair_Lo) { fPair_Lo->Set_v(x); } else { fIntercept[0]=x; } }
  if (plane==1) { if (fPair_Lo) { fPair_Lo->Set_u(x); } else { fIntercept[1]=x; } }
  
  if (plane==2) { if (fPair_Hi) { fPair_Hi->Set_v(x); } else { fIntercept[2]=x; } }
  if (plane==3) { if (fPair_Hi) { fPair_Hi->Set_u(x); } else { fIntercept[3]=x; } }
  
  UpdateTrackInfo(); 
}
double TvdcTrack::Intercept(int plane) const { 
  
  return fIntercept[plane]; 
}
int    TvdcTrack::Nhits(int plane) const { 
  
  if (!f_hasVDCdata) { 
    THRS::ReportError("TvdcTrack::Nhits(int)",
		      "Non-vdc track does not have TDC data.");
    return -999; 
  }
  
  if (!f_hasVDCdata || !fGroup[plane]) { 
    THRS::ReportError("TvdcTrack::Nhits(int)","Pointer for group invalid.");
    return -999; 
  }
  return fGroup[plane]->Nhits(); 
}
double TvdcTrack::Tau(int plane, int h) const {  
  
  if (!f_hasVDCdata) { 
    THRS::ReportError("TvdcTrack::Tau(int,int)",
		      "Non-vdc track does not have TDC data.");
    return -1e30; 
  }
  
  if (!fGroup[plane]) { 
    THRS::ReportError("TvdcTrack::Tau(int,int)","Pointer for group invalid.");
    return -1e30; 
  }
  
  if (h >= Nhits(plane) || h<0 ) { 
    THRS::ReportError("TvdcTrack::Tau(int,int)","Out-of-range hit requested."); 
    return -1e30; 
  }
  
  return fGroup[plane]->Time(h); 
}
double TvdcTrack::WirePos(int plane, int h) const {  
  
  if (!f_hasVDCdata) { 
    THRS::ReportError("TvdcTrack::WirePos(int,int)",
		      "Non-vdc track does not have TDC data.");
    return -1e30; 
  }
  
  if (!f_hasVDCdata || !fGroup[plane]) { 
    THRS::ReportError("TvdcTrack::WirePos(int,int)","Pointer for group invalid.");
    return -1e30; 
  }
  
  if (h >= Nhits(plane) || h<0 ) { 
    THRS::ReportError("TvdcTrack::WirePos(int,int)","Out-of-range hit requested."); 
    return -1e30; 
  }
  
  return fGroup[plane]->WirePos(h); 
}
double TvdcTrack::Slope(int plane)          const { 
  
  if (plane==0 || plane==2) { return fSlope_v; }
  if (plane==1 || plane==3) { return fSlope_u; }
  
  THRS::ReportError("TvdcTrack::Slope(int)","Invalid plane-num given."); 
  return -1e30; 
}

double ARRAY_rotate_uvw_to_xyz[9] = {  0.500000,  0.500000, -0.707107, 
				      -0.707107,  0.707107,  0.,
				       0.500000,  0.500000,  0.707107 }; 

double ARRAY_rotate_xyz_to_uvw[9] = {  0.500000, -0.707107,  0.500000, 
				       0.500000,  0.707107,  0.500000,
				      -0.707107,  0.,        0.707107 }; 


TVector3  TvdcTrack::Rotate_uvw_to_xyz( const TVector3 vec ) { 
  
  double ARRAY_vec[3] = { vec[0], vec[1], vec[2] }; 
  
  TVectorD r(3, ARRAY_vec); 
  
  TMatrixD U(3,3, ARRAY_rotate_uvw_to_xyz); 
  
  r = U*r; 

  return TVector3( r[0], r[1], r[2] ); 
}
TVector3  TvdcTrack::Rotate_xyz_to_uvw( const TVector3 vec ) { 
  
  double ARRAY_vec[3] = { vec[0], vec[1], vec[2] }; 
  
  TVectorD r(3, ARRAY_vec); 
  
  TMatrixD U(3,3, ARRAY_rotate_xyz_to_uvw); 
  
  r = U*r; 

  return TVector3( r[0], r[1], r[2] ); 
}
void TvdcTrack::Compute_Theta_Phi( const bool arm,  
				   const double intercepts[4], 
				   double &Theta, 
				   double &Phi ) { //static method
  
  double wSep = arm 
    ? VDC_w_R[2]-VDC_w_R[0] 
    : VDC_w_L[2]-VDC_w_L[0] ; 
  
  //compute slopes
  double m_v = wSep/(intercepts[2]-intercepts[0]); 
  double m_u = wSep/(intercepts[3]-intercepts[1]); 

  TVector3 S_xyz = TvdcTrack::Rotate_uvw_to_xyz( TVector3( 1./m_u, 1./m_v, 1. ) ); 
  
  Theta = TMath::ATan( S_xyz.X()/S_xyz.Z() ); 
  Phi   = TMath::ATan( S_xyz.Y()/S_xyz.Z() ); 
  
}  
TVector3 TvdcTrack::ComputeIntercept_w(const double w) const {
    
  return TVector3( fIntercept[1] + ( w - fW[1] )/fSlope_u, 
		   fIntercept[0] + ( w - fW[0] )/fSlope_v, w ); 
}
TVector3 TvdcTrack::ComputeIntercept_z(const double z) const {
  
  //get two arbitrary ponints on the track so we can interpolate to find 'z'
  TVector3 S  = TvdcTrack::Rotate_uvw_to_xyz( TVector3( 1./fSlope_u, 1./fSlope_v, 1. ) );  
  
  TVector3 r0 = TvdcTrack::Rotate_uvw_to_xyz( ComputeIntercept_w(0.) ); 
  
  double t    = ( z - r0.Z() )/S.Z();   
  
  return TVector3( r0  +  S*t ); 
}
double TvdcTrack::ToF(int plane, double x) const { 
  
  //U-plane (v-coord)
  if (plane==0 || plane==2) { return (fS2_v - x)/fC_v; }
  //V-plane (u-coord)
  else                      { return (fS2_u - x)/fC_u; }
}
double TvdcTrack::GetTimeAtZ(const double z) const {
  
  //computes the time which this track intercets some z-plane
  // (z in transport coords)
  // note that this time is given relative to the time of the S2-hit used to make
  // this track.
  
  //intercept with this plane, in uvw (vdc) coordinates
  TVector3 intercept_uvw
    = TvdcTrack::Rotate_xyz_to_uvw( ComputeIntercept_z(z) ); 
  
  double u = intercept_uvw[0];
  
  return (u - fS2_u)/fC_u;
}
double TvdcTrack::Get_T_model(int plane, double v, int derivative) const { 
  
  double slope = Slope(plane); 
  
  double w = slope*( v - Intercept(plane) ); 
  
  double Tau_model = fEvent->Drift_T( w,slope,derivative ); 
  
  //time-of-flight does not contribute to the derivatives of T
  if (derivative==0) Tau_model += -ToF( plane, v );   
  
  return Tau_model; 
}
double TvdcTrack::xParam() const { 
  
  return  
    ( f_S2Int_xyz.X() - fEvent->GetS2Hit()->X() ) 
    / fEvent->GetS2Hit()->PaddleWidth();     
}
void TvdcTrack::Nudge_params( double nudge[5] ) { 
  
  double u,v; 
  
  if ( !fPair_Lo || !fPair_Hi || !f_hasVDCdata ) { //is this a vdc-data track?
    
    for (int p=0; p<4; p++) fIntercept[p] += nudge[p]; 
    
  } else                                         { 
    
    fPair_Lo->Get_uv( u,v ); 
    fPair_Lo->Set_uv( u + nudge[1], 
		      v + nudge[0] );
    
    fPair_Hi->Get_uv( u,v ); 
    fPair_Hi->Set_uv( u + nudge[3], 
		      v + nudge[2] ); 
  } 
   
  fT0 += nudge[4]; 

  UpdateTrackInfo(); 
}
void   TvdcTrack::Set_params( const double vLo, 
			      const double uLo,
			      const double vHi, 
			      const double uHi, 
			      const double T0 ) { 
  
  if (fPair_Lo && fPair_Hi && f_hasVDCdata) {  
    
    fPair_Lo->Set_uv( uLo,vLo );
    fPair_Hi->Set_uv( uHi,vHi ); 
  
  } else  { 
    
    fIntercept[0] =vLo;
    fIntercept[1] =uLo;
    fIntercept[2] =vHi;
    fIntercept[3] =uHi;
  }
  
  fT0 = T0;  

  UpdateTrackInfo(); 
}
void   TvdcTrack::Set_params( const double params[5] ) { 
  
  Set_params( params[0], 
	      params[1], 
	      params[2], 
	      params[3], 
	      params[4] ); 

}
double TvdcTrack::FP_x()  const { return f_FPInt_xyz.X(); }
double TvdcTrack::FP_y()  const { return f_FPInt_xyz.Y(); }

double TvdcTrack::S2_x()  const { return f_S2Int_xyz.X(); }
double TvdcTrack::S2_y()  const { return f_S2Int_xyz.Y(); }

double TvdcTrack::Theta() const { return fTheta; }
double TvdcTrack::Phi()   const { return fPhi; }
////////////////////////////////////////////////////////////////////////////////////


ClassImp(THRS); 

ClassImp(TS2Hit);

ClassImp(TvdcHit);

ClassImp(THitGroup);

ClassImp(THitCluster); 

ClassImp(TChamberPair); 

ClassImp(TEventHandler); 

ClassImp(TvdcTrack); 
